<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="对象原型可以把script对象想象成为一张散列表，其中的内容就是一组键&#x2F;值对，值可以是数据或者函数。 创建对象使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足:创建具有同样接口的多个对象需要重复编写很多代码 12345678910111213141516&#x2F;&#x2F;方式一let person &#x3D; new Object();person.name &#x3D; &amp;#x27;ljt&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="原型">
<meta property="og:url" content="http://example.com/2022-01-05/%E5%8E%9F%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="对象原型可以把script对象想象成为一张散列表，其中的内容就是一组键&#x2F;值对，值可以是数据或者函数。 创建对象使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足:创建具有同样接口的多个对象需要重复编写很多代码 12345678910111213141516&#x2F;&#x2F;方式一let person &#x3D; new Object();person.name &#x3D; &amp;#x27;ljt&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/31.JPG">
<meta property="og:image" content="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/32.JPG">
<meta property="og:image" content="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/9.png">
<meta property="og:image" content="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/33.JPG">
<meta property="article:published_time" content="2022-01-05T07:40:15.000Z">
<meta property="article:modified_time" content="2022-02-08T08:52:12.158Z">
<meta property="article:author" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/31.JPG">

<link rel="canonical" href="http://example.com/2022-01-05/%E5%8E%9F%E5%9E%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>原型 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-01-05/%E5%8E%9F%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          原型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-05 15:40:15" itemprop="dateCreated datePublished" datetime="2022-01-05T15:40:15+08:00">2022-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-08 16:52:12" itemprop="dateModified" datetime="2022-02-08T16:52:12+08:00">2022-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h1><p>可以把script对象想象成为一张散列表，其中的内容就是一组键/值对，值可以是数据或者函数。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足:创建具<br>有同样接口的多个对象需要重复编写很多代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//方式一</span><br><span class="line">let person = new Object();</span><br><span class="line">person.name = &#x27;ljt&#x27;;</span><br><span class="line">person.age = 30;</span><br><span class="line">person.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方式二</span><br><span class="line">let person = &#123;</span><br><span class="line">    name:&#x27;ljt&#x27;,</span><br><span class="line">    age:30,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题(即新创建的对象是什么类型)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 工厂模式</span><br><span class="line">function createPerson(name, age) &#123;</span><br><span class="line">  let person = new Object();</span><br><span class="line">  person.name = name;</span><br><span class="line">  person.age = age;</span><br><span class="line">  person.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  return person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = createPerson(&#x27;ljt&#x27;, 30)</span><br><span class="line">let person2 = createPerson(&#x27;cdw&#x27;, 28)</span><br></pre></td></tr></table></figure>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>和工厂模式的区别：<br>1、没有显式的创建对象<br>2、属性和方法直接赋值给了this<br>3、没有return<br>创建对象主要是使用了<strong>new 操作符</strong>，new操作符的实质操作：</p>
<ul>
<li>1、在内存中新建一个对象</li>
<li>2、这个对象的[[prototype]]特性被赋值为构造函数的prototype属性 （【该如何理解】，将这个对象的[[prototype]]指向原型）</li>
<li>3、构造函数内部的this被赋值为这个新对象（即this指向这个新对象）</li>
<li>4、执行构造函数内部的代码（给新对象添加属性）</li>
<li>5、如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象</li>
</ul>
<p>在下面的例子中person1 和 person2 分别保存着 Person 的不同实例<br>constructor 本来是用于标识对象类型的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// console.log(person1.constructor == Person);</span><br><span class="line">// console.log(person2.constructor == Person);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 构造函数模式</span><br><span class="line">function Person(name,age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.sayName = function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let person1 = new Person(&#x27;ljt&#x27;, 30)</span><br><span class="line">let person2 = new Person(&#x27;cdw&#x27;, 28)</span><br><span class="line"></span><br><span class="line">person1.sayName();</span><br><span class="line">person2.sayName();</span><br></pre></td></tr></table></figure>

<p>构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1 和 person2 都有名为 sayName()的方法，但这两个方 法不是同一个 Function 实例；<br>还可以将sayName方法定义在构造函数外部，构造函数内部，sayName 属性等于全局 sayName() 函数，包含的只是一个指向外部函数的指针，这样虽然解决了相同逻辑的函数重复定义的问题，但 全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例 共享的属性和方法,实际上，这个对象就是通过调用构造函数创建的对象的原型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &#x27;ljt&#x27;</span><br><span class="line">Person.prototype.age = 30</span><br><span class="line">Person.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person1 = new Person()</span><br><span class="line">let person2 = new Person()</span><br><span class="line"></span><br><span class="line">person1.sayName();</span><br><span class="line">person2.sayName();</span><br></pre></td></tr></table></figure>

<h4 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h4><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性(指向原型对象)，默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数，<strong>Person.prototype.constructor 指向 Person</strong></p>
<p>特别理解：<br>在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。关键在于：实例与构造函数原型之间有直接的联系，但是实例直接没有直接关系。</p>
<p>构造函数，实例，原型对象是3个完全不同的对象。<br>实例通过__proto__链接到原型对象，实际上指向的是隐藏属性[[Prototype]]（换句话说：[[Prototype]]出现在实例内部，指向原型对象，不可直接访问，可以通过浏览器暴露出来的__proto__属性访问）<br>构造函数通过prototype属性连接到原型对象，实例与构造函数没有直接联系，与原型对象有直接联系<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/31.JPG" alt="avatar"><br>通过对象访问属性时，<br>1、先搜索实例本身，如果实例上发现了给定名称，则直接访问该属性值<br>2、如果在实例中没有找到，则沿着原型指针进入原型对象中寻找，如果寻找到则返回对应值<br>3、如果原型中也没有找到，则返回undefined</p>
<p>例外的：<br>如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性<br><code>hasOwnProperty()</code>方法用于确定某个属性是在实例上还是在原型对象上</p>
<p>原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。但是当包含引用值的属性时就会出现意外，如果修改了原型上的引用属性，则会影响到所有的实例，如下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123; &#125;</span><br><span class="line">Person.prototype.name = &#x27;ljt&#x27;;</span><br><span class="line">Person.prototype.age = 30;</span><br><span class="line">Person.prototype.friends = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="line">Person.prototype.helloFriends = function () &#123;</span><br><span class="line">  console.log(this.friends);</span><br><span class="line">&#125;</span><br><span class="line">let person1 = new Person()</span><br><span class="line">let person2 = new Person()</span><br><span class="line">person1.helloFriends();</span><br><span class="line">//  [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line">person2.helloFriends();</span><br><span class="line">//  [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class="line"></span><br><span class="line">//修改原型的引用属性</span><br><span class="line">person1.friends.push(&#x27;c&#x27;)</span><br><span class="line"></span><br><span class="line">//所有相关的实例都会收到影响</span><br><span class="line">person1.helloFriends();</span><br><span class="line">//  [&#x27;a&#x27;, &#x27;b&#x27;，&#x27;c&#x27;]</span><br><span class="line">person2.helloFriends();</span><br><span class="line">//  [&#x27;a&#x27;, &#x27;b&#x27;，&#x27;c&#x27;]</span><br></pre></td></tr></table></figure>


<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型，如果原型是另一个类型的实例，这个原型内部有一个内部指针[[prototype]]指向另一个类型的原型，这个原型有一个指针指向另一个构造函数。这样就形成了一个继承链。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">  this.property = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function () &#123;</span><br><span class="line">  return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">  this.subProperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = function () &#123;</span><br><span class="line">  return this.subProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance = new SubType();</span><br><span class="line"></span><br><span class="line">instance.getSuperValue();</span><br></pre></td></tr></table></figure>

<p>继承图如下：<br>调用 instance.getSuperValue()经过了 3 步搜索:instance、 SubType.prototype 和 SuperType.prototype，最后一步才找到这个方法<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/32.JPG" alt="avatar"></p>
<p>默认的原型链：<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/9.png" alt="avatar"></p>
<p>原型链的问题：<br>第一个问题：前面也提到过，主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因<br>第二个问题：子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。（【怎么理解】传递参数相当于直接修改了子类型的原型，会影响到所有的子类型实例）</p>
<h3 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h3><p>在子类 构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply()和 call()方法以新创建的对象为上下文执行构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">  // 继承SuperType，通过call还可以向父类型的构造函数传递参数</span><br><span class="line">  SuperType.call(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors);</span><br><span class="line">// &quot;red,blue,green,black&quot;</span><br><span class="line"></span><br><span class="line">let instance2 = new SubType();</span><br><span class="line">console.log(instance2.colors);</span><br><span class="line">// &quot;red,blue,green&quot;</span><br></pre></td></tr></table></figure>
<p>通过使用 call()(或 apply())方法，SuperType 构造函数在为 SubType 的实例创建的新对象的上下文中执行了。这相当于新的 SubType 对象上运行了 SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的 colors 属性</p>
<p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题:必须在构造函数中定义方法，因此函数不能重用。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承(有时候也叫伪经典继承)综合了原型链和盗用构造函数，将两者的优点集中了起来。基 本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.property = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new SubType(&quot;ljt&quot;, 30);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors);</span><br><span class="line">// &quot;red, blue, green, black&quot;</span><br><span class="line"></span><br><span class="line">instance1.sayName();</span><br><span class="line">// &quot;ljt&quot;;</span><br><span class="line"></span><br><span class="line">instance1.sayAge();</span><br><span class="line">// 30</span><br><span class="line"></span><br><span class="line">let instance2 = new SubType(&quot;cdw&quot;, 28);</span><br><span class="line">console.log(instance1.colors);</span><br><span class="line">// &quot;red, blue, green&quot;</span><br><span class="line"></span><br><span class="line">instance2.sayName();</span><br><span class="line">// &quot;cdw&quot;;</span><br><span class="line"></span><br><span class="line">instance2.sayAge();</span><br><span class="line">// 28</span><br></pre></td></tr></table></figure>
<p>继承图如下：<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/33.JPG" alt="avatar"></p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>类似于原型继承,object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返 4 回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function object(o) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原型式继承适用于这种情况:你有一个对象，想在它的基础上再创建一个新对象.<br>Object.create()方法将原型式继承的概念规范化了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;hello&#x27;,</span><br><span class="line">  friends: [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = Object.create(person);</span><br><span class="line">instance1.name = &#x27;ljt&#x27;</span><br><span class="line">instance1.friends.push(&#x27;c&#x27;);</span><br><span class="line"></span><br><span class="line">let instance2 = Object.create(person);</span><br><span class="line">instance2.name = &#x27;cdw&#x27;</span><br><span class="line">instance1.friends.push(&#x27;d&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(person.friends);</span><br><span class="line">// &quot;a, b, c, d&quot;</span><br></pre></td></tr></table></figure>
<p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的</p>
<h3 id="寄生继承"><a href="#寄生继承" class="headerlink" title="寄生继承"></a>寄生继承</h3><p>寄生式继承背后的思路类似于寄生构造函数和工厂模式:创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//createAnother()函数接收一个参数，就是新对象的基准对象。</span><br><span class="line">// 这个对象 original 会被传给 object()函数，</span><br><span class="line">// 然后将返回的新对象赋值给 clone。</span><br><span class="line">// 接着给 clone 对象添加一个新方法 sayHi()</span><br><span class="line">function createAnother(o) &#123;</span><br><span class="line">  // 通过调用函数创建一个新对象</span><br><span class="line">  let clone = Object.create(o)</span><br><span class="line">  // 以某种方式增强这个对象</span><br><span class="line">  clone.sayHi = function () &#123;</span><br><span class="line">    console.log(&quot;hi&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  // 返回新对象</span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次:一次在是 创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调 用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父 类原型，然后将返回的新对象赋值给子类原型，基本原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 在这个函数内部，第一步是创建父类原型的一个副本。</span><br><span class="line">// 然后，给返回的 prototype 对象设置 constructor 属性，</span><br><span class="line">// 解决由于重写原型导致默认 constructor 丢失的问题。</span><br><span class="line">// 最后将新创建的对象赋值给子类型的原型</span><br><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    // 创建新对象,取父类原型的副本</span><br><span class="line">    let prototype = object(superType.prototype);</span><br><span class="line">    // 增强新对象，给对象设置 constructor 属性，</span><br><span class="line">    // 解决由于重写原型导致默认 constructor 丢失的问题</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    // 新创建的对象赋值给子类型的原型</span><br><span class="line">    subType.prototype = prototype; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SubType.property = new SuperType();</span><br><span class="line">// SubType.prototype.constructor = SubType;</span><br><span class="line">inheritPrototype(SubType, SuperType); // 重点</span><br><span class="line">SubType.prototype.sayAge = function () &#123;</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let instance1 = new SubType(&quot;ljt&quot;, 30);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">console.log(instance1.colors);</span><br><span class="line">// &quot;red, blue, green, black&quot;</span><br><span class="line"></span><br><span class="line">instance1.sayName();</span><br><span class="line">// &quot;ljt&quot;;</span><br><span class="line"></span><br><span class="line">instance1.sayAge();</span><br><span class="line">// 30</span><br><span class="line"></span><br><span class="line">let instance2 = new SubType(&quot;cdw&quot;, 28);</span><br><span class="line">console.log(instance1.colors);</span><br><span class="line">// &quot;red, blue, green&quot;</span><br><span class="line"></span><br><span class="line">instance2.sayName();</span><br><span class="line">// &quot;cdw&quot;;</span><br><span class="line"></span><br><span class="line">instance2.sayAge();</span><br><span class="line">// 28</span><br></pre></td></tr></table></figure>

<p>寄生式组合继承调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说这个例子的效率更高</p>
<h2 id="new操作符执行的操作"><a href="#new操作符执行的操作" class="headerlink" title="new操作符执行的操作"></a>new操作符执行的操作</h2><p>1、内存中创建一个新的对象<br>2、将新对象的[[prototype]]属性赋值为构造函数的prototype属性，即指向原型<br>3、构造函数中的this绑定到这个新对象（通过this为新对象增加属性）<br>4、执行构造函数内部的代码，为这个新对象增加属性<br>5、如果构造函数返回非对象，则返回这个对象；否则返回刚刚创建的新对象</p>
<h2 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h2><p>1、this永远指向一个对象<br>2、this的指向完全取决于函数调用的上下文</p>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">    console.log(this.s);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">var obj = &#123;</span><br><span class="line">    s:&#x27;1&#x27;,</span><br><span class="line">    f:fun</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">var s = &#x27;2&#x27;;</span><br><span class="line">​</span><br><span class="line">obj.f(); //1</span><br><span class="line">fun(); //2</span><br></pre></td></tr></table></figure>

<p>obj.f()的调用中，因为运行环境在obj对象内，因此函数中的this指向对象obj<br>全局作用域下调用 fun() ，函数中的 this 就会指向全局作用域对象window</p>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;</span><br><span class="line">    name: &#x27;张三&#x27;,</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        console.log(&#x27;姓名：&#x27; + this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">var B = &#123;</span><br><span class="line">    name: &#x27;李四&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">B.f = A.f;</span><br><span class="line">B.f()   // 姓名：李四</span><br><span class="line">A.f()   // 姓名：张三</span><br></pre></td></tr></table></figure>

<h3 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // &#x27;window&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="示例四"><a href="#示例四" class="headerlink" title="示例四"></a>示例四</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &#x27;轩辕Rowboat&#x27;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">    other: &#123;</span><br><span class="line">        name: &#x27;other&#x27;,</span><br><span class="line">        doSth: doSth,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); // &#x27;轩辕Rowboat&#x27;</span><br><span class="line">student.other.doSth(); // &#x27;other&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.doSth.call(student);</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.other.doSth.call(student.other);</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022-01-04/http%E7%BC%93%E5%AD%98/" rel="prev" title="http缓存">
      <i class="fa fa-chevron-left"></i> http缓存
    </a></div>
      <div class="post-nav-item">
    <a href="/2022-01-05/%E7%BD%91%E7%BB%9C%E6%8F%A1%E6%89%8B%E7%9B%B8%E5%85%B3/" rel="next" title="网络握手相关">
      网络握手相关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">对象原型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.</span> <span class="nav-text">创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">构造函数模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">理解原型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">1.2.1.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">盗用构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.3.</span> <span class="nav-text">组合继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.4.</span> <span class="nav-text">原型式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E7%94%9F%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.5.</span> <span class="nav-text">寄生继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.6.</span> <span class="nav-text">寄生式组合继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">new操作符执行的操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">this指向问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80"><span class="nav-number">1.4.1.</span> <span class="nav-text">示例一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C"><span class="nav-number">1.4.2.</span> <span class="nav-text">示例二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89"><span class="nav-number">1.4.3.</span> <span class="nav-text">示例三</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%9B%9B"><span class="nav-number">1.4.4.</span> <span class="nav-text">示例四</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hexo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hexo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
