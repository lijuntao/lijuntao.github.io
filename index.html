<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LJT的杂货铺">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="LJT的杂货铺">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ljt">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>LJT的杂货铺</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LJT的杂货铺</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这个家伙太懒</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-05-07/HTML%E6%A0%87%E7%AD%BE%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-05-07/HTML%E6%A0%87%E7%AD%BE%E5%B8%B8%E7%94%A8%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">HTML标签常用元素</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-07 14:33:40 / 修改时间：15:44:44" itemprop="dateCreated datePublished" datetime="2022-05-07T14:33:40+08:00">2022-05-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="lt-DOCTYPE-html-gt"><a href="#lt-DOCTYPE-html-gt" class="headerlink" title="&lt;!DOCTYPE html&gt;"></a><code>&lt;!DOCTYPE html&gt;</code></h1><p><strong>这是文档类型声明，一般位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型规范来解析这个文档。<code>&lt;!DOCTYPE html&gt;</code>表示以HTML5规范解析页面</strong></p>
<p>延伸：严格模式，混合模式</p>
<ul>
<li><p>严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码</p>
</li>
<li><p>混合模式：又称怪异模式，是指浏览器用自己的方式解析代码。</p>
</li>
</ul>
<h1 id="常见mate属性"><a href="#常见mate属性" class="headerlink" title="常见mate属性"></a>常见mate属性</h1><p>用法：</p>
<ul>
<li><p>声明字符编码 例：<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></p>
</li>
<li><p>指定名/值对 例：<code>&lt;meta name=&quot;参数&quot; content=&quot;具体描述信息&quot;&gt;</code></p>
</li>
<li><p>关联http头部 例：<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code></p>
</li>
</ul>
<p><strong>除charset属性外，都是http-equiv属性或name属性结合content来使用</strong></p>
<h2 id="声明字符编码"><a href="#声明字符编码" class="headerlink" title="声明字符编码"></a>声明字符编码</h2><ul>
<li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> 声明文档的字符编码</li>
</ul>
<h2 id="指定名-值对"><a href="#指定名-值对" class="headerlink" title="指定名/值对"></a>指定名/值对</h2><ul>
<li><p><code>&lt;meta name=&quot;keywords&quot; contect=&quot;&quot;&gt;</code> 页面关键词</p>
</li>
<li><p><code>&lt;meta name=&quot;description&quot; contect=&quot;&quot;&gt;</code> 页面描述</p>
</li>
<li><p><code>&lt;meta name=&quot;author&quot; content=&quot;author,email address&quot;&gt;</code> 页面作者</p>
</li>
<li><p><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</code> 搜索引擎索引方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">  all：文件将被检索，且页面上的链接可以被查询；</span><br><span class="line">  none：文件将不被检索，且页面上的链接不可以被查询；</span><br><span class="line">  index：文件将被检索；</span><br><span class="line">  follow：页面上的链接可以被查询；</span><br><span class="line">  noindex：文件将不被检索；</span><br><span class="line">  nofollow：页面上的链接不可以被查询。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code> 移动端页面布局</p>
</li>
<li><p><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code> 指定以哪种内核解析页面</p>
</li>
</ul>
<h2 id="关联http头部"><a href="#关联http头部" class="headerlink" title="关联http头部"></a>关联http头部</h2><p>  http-equiv属性与content属性结合使用,向浏览器提供一些说明信息，从而可以根据这些说明做出反应</p>
<ul>
<li><p><code>&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html charset=UTF-8&quot;&gt;</code> 声明文档的字符编码</p>
</li>
<li><p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code> 指定IE和Chrome使用最新版本渲染当前页面</p>
</li>
<li><p><code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</code> 指定请求和响应遵循的缓存机制 <strong>不是所有的浏览器都支持</strong></p>
</li>
<li><p><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;2；URL=http://www.baidu.com/&quot;&gt;</code> //意思是2秒后跳转向我的博客</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-05-07/Ajax-Fetch-Axios%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-05-07/Ajax-Fetch-Axios%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Ajax_Fetch_Axios三者的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-07 14:20:43 / 修改时间：14:21:59" itemprop="dateCreated datePublished" datetime="2022-05-07T14:20:43+08:00">2022-05-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>全称是：Asynchronous JavaScript And XML 即：“异步的JavaScript 和 XML”<br>Ajax是一个技术统称，是一个概念模型，他囊括了很多技术，并不特定指某一技术，他的一个重要特性就是实现界面的局部刷新。<br>简单的来说：Ajax是一种思想，XMLHttpRequest只是实现Ajax的一种方式</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios是一个网络请求库，利用XMLHttpRequst进行了二次封装的请求库，但是XMLHttpRequst只是axios中的其中一个请求适配器，还可以采用其他请求适配器</p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>Fetch是ES6出现的，他使用了ES6提出的promise对象，是XHLHttpRequest的替代品。<br>通常会拿他与Ajax做比较，严格来说这是不对的，我们通常所说的Ajax是指使用XMLHttpRequst实现的Ajax，所以真正应该是和XMLHttpRequst作比较。<br><code>Fetch 是一个 API，它是真实存在的，它是基于 promise 的。</code></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><table>
<thead>
<tr>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Ajax</td>
<td>一种技术统称，主要利用XHR实现网络请求</td>
</tr>
<tr>
<td>Axios</td>
<td>一个封装库</td>
</tr>
<tr>
<td>Fetch</td>
<td>具体API，基于promise，实现网络请求</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-04-19/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-04-19/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JavaScript内存管理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-19 14:35:43" itemprop="dateCreated datePublished" datetime="2022-04-19T14:35:43+08:00">2022-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-18 17:00:56" itemprop="dateModified" datetime="2022-05-18T17:00:56+08:00">2022-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JavaScript内存管理机制</p>
<p>常用的GC算法</p>
<p>引用计数</p>
<p>没有引用指向该对象（零引用），对象将被垃圾回收机制回收<br>弊端：<br>无法处理循环引用的事例</p>
<p>标记-清除</p>
<p>垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p>
<p>标记-整理</p>
<p>标记清除有空间碎片化的缺点，标记整理是标记清除的增强。标记整理在标记阶段的操作和标记清除一致，但是在清除阶段会先执行整理，再进行清除。</p>
<p>V8引擎的分代回收策略</p>
<p>将内存分为新生代和旧生代两种，并对不同的对象采用不同的算法。</p>
<p>新生代内存</p>
<p>采用Scavenge算法进行垃圾回收，在具体实现中采用了Cheney算法。具体逻辑如下：</p>
<p>将新生代内存分为两个等大的空间，一个空间为From，一个空间为To<br>当我们分配对象时，先在From空间进行分配，当前活动的对象也存储在From空间中<br>当触发进行垃圾回收时，会检查From空间中的存活对象，将存活对象复制到To空间，非存活对象被自动回收<br>当复制完成之后From空间和To空间进行一次角色互换，即To空间会变为新的From空间，原来的From空间则变为To空间<br>对象晋升：<br>当一个对象在经历多次复制之后依旧存活，则会被认为是一个生命周期较长的对象，在下次进行垃圾回收时，该对象会被直接转移到老生代内存中，这种行为称为晋升。<br>对象是否经历过了一次Scavenge算法<br>To空间的内存占比是否已经超过25%<br>老生代内存</p>
<p>在老生代内存中，管理着大量的存活对象，主要采用标记清除算法和标记清理算法<br>标记清除算法主要进行垃圾对象回收<br>标记清理算法主要解决内存碎片问题<br>为了减少垃圾回收带来的停顿时间，V8引擎又引入了【增量标记】的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。</p>
<p>增量标记法为什么能优化效率？<br>因为增量标记算法是将一整个的垃圾回收分为多个小的垃圾回收，这样就会使垃圾回收与程序的执行进行交替的工作，这样可以使时间上的消耗及程序停顿的时间更加的合理一些。</p>
<h2 id="JS什么情况下会出现内存泄漏"><a href="#JS什么情况下会出现内存泄漏" class="headerlink" title="JS什么情况下会出现内存泄漏"></a>JS什么情况下会出现内存泄漏</h2><p>现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进。<br>此算法的大致步骤：</p>
<ul>
<li>1、设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象</li>
<li>2、垃圾回收器将所有可以获得的对象（活动对象）和所有不能获得的对象（垃圾对象）做出标记</li>
<li>3、垃圾回收器释放垃圾对象所占用的内存并将其返回给操作系统</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>这是一个经典的闭包造成内存泄漏的例子，具体的理解：【暂时不理解、稍后补上】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var theThing = null;</span><br><span class="line">var replaceThing = function () &#123;</span><br><span class="line">  var originalThing = theThing;</span><br><span class="line">  var unused = function () &#123;</span><br><span class="line">    if (originalThing)</span><br><span class="line">      console.log(&quot;hi&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    longStr: new Array(1000000).join(&#x27;*&#x27;),</span><br><span class="line">    someMethod: function () &#123;</span><br><span class="line">      console.log(someMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">setInterval(replaceThing, 1000);</span><br></pre></td></tr></table></figure>

<h3 id="没有-DOM-引用"><a href="#没有-DOM-引用" class="headerlink" title="没有 DOM 引用"></a>没有 DOM 引用</h3><p>如下代码所示：有一个变量elements持有了对button节点的引用，为了在函数daStuff中使用。但是在将来的某一时刻将button节点从DOM树中移除了，<code>document.body.removeChild(document.getElementById(&#39;button&#39;));</code>。这个时候直觉上会认为垃圾回收器会把button节点回收，但实际上不会发生，因为elements还持有对button节点的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var elements = &#123;</span><br><span class="line">    button: document.getElementById(&#x27;button&#x27;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function doStuff() &#123;</span><br><span class="line">    button.click();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    // The button is a direct child of body.</span><br><span class="line">    document.body.removeChild(document.getElementById(&#x27;button&#x27;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="意外的使用全局变量"><a href="#意外的使用全局变量" class="headerlink" title="意外的使用全局变量"></a>意外的使用全局变量</h3><p>方式一：<br>假设你想在一个函数foo中创建一个变量，但是忘记使用var或者let声明，这样就会创建一个全局变量挂在在全局对象window上，而这些变量垃圾回收器是不会对这些变量回收的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg) &#123;</span><br><span class="line">    bar = &quot;this is a hidden global variable&quot;;</span><br><span class="line">&#125;</span><br><span class="line">或者：</span><br><span class="line">function foo(arg) &#123;</span><br><span class="line">    window.bar = &quot;this is an explicit global variable&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种情况是 错误的使用了this：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    this.variable = &quot;potential accidental global&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 直接调用函数foo，实际上是在window上调用了foo，this指向的是window。</span><br><span class="line">// 同样的创建了全局变量</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p>备注：当启用JS的严格模式时，<code>&#39;use strict&#39;;</code>,这种情况是不允许的</p>
<h3 id="遗忘的定时器或者回调"><a href="#遗忘的定时器或者回调" class="headerlink" title="遗忘的定时器或者回调"></a>遗忘的定时器或者回调</h3><p>定时器<br>使用<code>setInterval</code>在JS代码中是很常用的一个操作，用来循环的执行一些功能，如下面一段代码，<code>setInterval</code>对Node节点持有一个引用。如果在某一时刻将DOM中的Node节点删除。这个时候这段代码就是一段无效代码。但是因为<code>setInterval</code>依旧处于活动状态，内部还是会持有对Node和someResource的引用，垃圾回收器无法回收定时器所引用的对象。<br>解决方案：当定时器无效时，清除定时器 <code>clearInterval(timerId);</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var someResource = getData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var node = document.getElementById(&#x27;Node&#x27;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        // Do stuff with node and someResource.</span><br><span class="line">        node.innerHTML = JSON.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>观察者模式：<br>旧版本IE浏览器无法检测DOM节点和JS代码之间的循环引用。每次将观察者添加到IE中的节点时，都会导致泄漏，所以用户再删除节点之前需要先移除事件监听。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&#x27;button&#x27;);</span><br><span class="line"></span><br><span class="line">function onClick(event) &#123;</span><br><span class="line">    element.innerHtml = &#x27;text&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">element.addEventListener(&#x27;click&#x27;, onClick);</span><br><span class="line"></span><br><span class="line">// 移除事件监听器</span><br><span class="line">element.removeEventListener(&#x27;click&#x27;, onClick);</span><br><span class="line">element.parentNode.removeChild(element);</span><br></pre></td></tr></table></figure>
<p>现代浏览器使用现代垃圾收集算法，一般情况下可以检测这些循环并正确处理它们</p>
<h2 id="减少垃圾回收的tips"><a href="#减少垃圾回收的tips" class="headerlink" title="减少垃圾回收的tips"></a>减少垃圾回收的tips</h2><ul>
<li>清空一个数组时可以直接将数组长度设置为0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = [1, 2, 3, 4];</span><br><span class="line">//empty your array</span><br><span class="line">list.length = 0;</span><br></pre></td></tr></table></figure></li>
<li>对于不再使用的对象可以将对象设置为null</li>
<li>函数如果能复用尽量复用，特别是循环中使用的函数</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-04-13/npm-run-xxx%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-04-13/npm-run-xxx%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">npm_run_xxx执行过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-13 14:07:54 / 修改时间：14:08:11" itemprop="dateCreated datePublished" datetime="2022-04-13T14:07:54+08:00">2022-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="npm-run-xxx执行过程"><a href="#npm-run-xxx执行过程" class="headerlink" title="npm run xxx执行过程"></a>npm run xxx执行过程</h1><h2 id="第一问-当输入npm-run-xxx时发生了什么？"><a href="#第一问-当输入npm-run-xxx时发生了什么？" class="headerlink" title="第一问 当输入npm run xxx时发生了什么？"></a>第一问 当输入npm run xxx时发生了什么？</h2><p>当输入npm run xxx时，首先回去package.json文件中寻找scripts字段里面对应的xxx命令，如果找到，然后执行，如果没有找到则报错<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-scripts test&quot;,</span><br><span class="line">    &quot;eject&quot;: &quot;react-scripts eject&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="第二问-为什么不直接执行-react-scripts-start（举例）"><a href="#第二问-为什么不直接执行-react-scripts-start（举例）" class="headerlink" title="第二问 为什么不直接执行 react-scripts start（举例）"></a>第二问 为什么不直接执行 react-scripts start（举例）</h2><p>因为直接执行react-scripts start会报错，因为系统中没有存在react-scripts start这一条指令</p>
<h2 id="第三问-为什么通过npm-run执行时却可以执行"><a href="#第三问-为什么通过npm-run执行时却可以执行" class="headerlink" title="第三问 为什么通过npm run执行时却可以执行"></a>第三问 为什么通过npm run执行时却可以执行</h2><p>安装依赖的时候，是通过npm i xxx 来执行的，例如 npm i xxx在安装这个依赖的时候，就会node_modules/.bin/ 目录中创建好react-script的执行文件，如图，.bin目录下的表示这是一个一个的软链接，链接到具体执行的脚本文件<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/56.png"><br>所以执行<code>npm run start</code>等于执行<code>./node_modules/.bin/react-scripts serve</code>，实际最后等于执行<code>../react-scripts/bin/react-scripts.js serve</code></p>
<h2 id="第四问-那这个软链接是什么时候，怎么创建的呢？"><a href="#第四问-那这个软链接是什么时候，怎么创建的呢？" class="headerlink" title="第四问 那这个软链接是什么时候，怎么创建的呢？"></a>第四问 那这个软链接是什么时候，怎么创建的呢？</h2><p>关键就在于react-script这个包的package.json中的bin字段<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/57.png"><br>在 npm i react-script 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了</p>
<h2 id="第五问-npm-install-g-xxx-安装会怎样"><a href="#第五问-npm-install-g-xxx-安装会怎样" class="headerlink" title="第五问  npm install -g xxx 安装会怎样"></a>第五问  npm install -g xxx 安装会怎样</h2><p>全局安装时，会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-03-11/Redux%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-03-11/Redux%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">Redux知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-11 10:15:23 / 修改时间：10:16:10" itemprop="dateCreated datePublished" datetime="2022-03-11T10:15:23+08:00">2022-03-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redux相关"><a href="#Redux相关" class="headerlink" title="Redux相关"></a>Redux相关</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>导出redux所暴露的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123;</span><br><span class="line">  createStore,</span><br><span class="line">  combineReducers,</span><br><span class="line">  bindActionCreators,</span><br><span class="line">  applyMiddleware,</span><br><span class="line">  compose</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>创建redux所需的store数据对象，包含当前数据状态和修改数据状态的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 整个文件只导出一个函数，就是createStore函数。参数如下：</span><br><span class="line">// * reducer - 我们传入的reducer纯函数，用来定义我们的state可以做的操作，如果不懂它的概念可以参考上一篇文章</span><br><span class="line">// * preloadedState - state的初始化值</span><br><span class="line">// * enhancer - 当我们需要使用middleware的时候，会用到。</span><br><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  // 如果传入了第三方插件，则使用第三方插件来创建store</span><br><span class="line">  // 具体实现方式可参考applyMiddleware</span><br><span class="line">  if (typeof enhancer !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">    // 第三方插件</span><br><span class="line">    return enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 当前的reducer。Redux支持我们替换当前的reducer为另一个函数</span><br><span class="line">  let currentReducer = reducer</span><br><span class="line">  // 用来存储我们整个程序的状态</span><br><span class="line">  let currentState = preloadedState</span><br><span class="line">  // 状态监听函数，当状态发生改变的时候会被调用。可以注册多个监听函数。</span><br><span class="line">  let currentListeners = []</span><br><span class="line">  // 这个是为了处理一些异常情况而保存一份currentListeners的shallow copy副本，不影响核心逻辑的理解，可以暂时忽略</span><br><span class="line">  let nextListeners = currentListeners</span><br><span class="line"></span><br><span class="line">  // 提供给外部调用，用来获取当前state。由于state是Redux的内部变量，外部只能通过API函数来获取状态。</span><br><span class="line">  function getState() &#123;</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注册监听器，listener是回调函数，当状态被修改的时候调用</span><br><span class="line">  function subscribe(listener) &#123;</span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">      const index = nextListeners.indexOf(listener)</span><br><span class="line">      nextlisteners.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // dispatch用来修改一个状态</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching = true</span><br><span class="line">      // 调用当前的reducer，传入当前状态和action，然后将返回值更新为新状态</span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching = false</span><br><span class="line">    &#125;</span><br><span class="line">    // 依次调用监听器函数</span><br><span class="line">    const listeners = (currentListeners = nextListeners)</span><br><span class="line">    for (let i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      const listener = listeners[i]</span><br><span class="line">      listener()</span><br><span class="line">    &#125;</span><br><span class="line">    return action</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更换reducer函数</span><br><span class="line">  function replaceReducer(nextReducer) &#123;</span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.REPLACE &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // dispatch一个INIT事件，外部可以监听这个事件，用于一些初始化的工作</span><br><span class="line">  dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line">  // 返回值是一个对象，包含了用于获取和操作状态的函数</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>将多个reducer合并为一个总的reducer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 整个文件导出一个函数</span><br><span class="line">// 参数reducers是一个Object，比如一个todo app可能包含users和todos两部分数据，</span><br><span class="line">// 那么它的格式如下：</span><br><span class="line">// &#123;</span><br><span class="line">//    users: function userReducer()&#123;&#125;,</span><br><span class="line">//    todos: function todoReducer()&#123;&#125;,</span><br><span class="line">// &#125;</span><br><span class="line">export default function combineReducers(reducers) &#123;</span><br><span class="line">  // 获取参数reducers中的key</span><br><span class="line">  const reducerKeys = Object.keys(reducers)</span><br><span class="line">  // 将reducers重新赋值给finalReducers</span><br><span class="line">  // 这一步主要用于排除reducers中非函数的子reducer</span><br><span class="line">  const finalReducers = &#123;&#125;</span><br><span class="line">  for (let i = 0; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    const key = reducerKeys[i]</span><br><span class="line">    // 保证每个子reducer都是一个函数</span><br><span class="line">    if (typeof reducers[key] === &#x27;function&#x27;) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 重新获取reducers中的key</span><br><span class="line">  const finalReducerKeys = Object.keys(finalReducers)</span><br><span class="line"></span><br><span class="line">  //返回一个函数，参数为当前全局大的state，action</span><br><span class="line">  return function combination(state = &#123;&#125;, action) &#123;</span><br><span class="line">    // 是否已改变</span><br><span class="line">    let hasChanged = false</span><br><span class="line">    // action之后的state</span><br><span class="line">    const nextState = &#123;&#125;</span><br><span class="line">    // 遍历reducer，依次对reducer进行操作</span><br><span class="line">    for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      const key = finalReducerKeys[i]</span><br><span class="line">      const reducer = finalReducers[key]</span><br><span class="line">      // 获取这个子reducer对应的state</span><br><span class="line">      const previousStateForKey = state[key]</span><br><span class="line">      // 调用这个子reducer对state中的数据进行修改</span><br><span class="line">      const nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      // 将修改后的state赋值给大的state</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      // 判断state是否改变，只要有一个子state改动过，即判定整个大的state已修改</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    return hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bindActionCreators函数"><a href="#bindActionCreators函数" class="headerlink" title="bindActionCreators函数"></a>bindActionCreators函数</h3><p>bindActionCreator(dealAction,diapatch)函数返回的是一个对象，调用这个对象中（对应相应action）的属性，就会自动创建aciton并dispatch<br>主要作用：将一个或多个action和dispatch组合起来，每一个action中不在具体的调用dispatch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 假如有这样的action</span><br><span class="line">export function addTodo(text) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function removeTodo(id) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &#x27;REMOVE_TODO&#x27;,</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出结果</span><br><span class="line">&#123;</span><br><span class="line">   addTodo : text =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">      text</span><br><span class="line">    &#125;,</span><br><span class="line">   removeTodo : id =&gt; &#123;</span><br><span class="line">      type: &#x27;REMOVE_TODO&#x27;,</span><br><span class="line">      id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//经过bindActionCreators之后</span><br><span class="line">&#123;</span><br><span class="line">   addTodo : text =&gt; dispatch(addTodo(&#x27;text&#x27;));</span><br><span class="line">   removeTodo : id =&gt; dispatch(removeTodo(&#x27;id&#x27;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 对单个actionCreator执行</span><br><span class="line">// 这个函数的主要作用就是返回一个函数，当我们调用返回的这个函数的时候，就会自动的dispatch对应的action</span><br><span class="line">function bindActionCreator(actionCreator, dispatch) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 翻转执行dispatch(actionCreator)</span><br><span class="line">    return dispatch(actionCreator.apply(this, arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 支持传入数组，并对数组中的每一项执行bindActionCreator</span><br><span class="line">export default function bindActionCreators(actionCreators, dispatch) &#123;</span><br><span class="line">  if (typeof actionCreators === &#x27;function&#x27;) &#123;</span><br><span class="line">    return bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const keys = Object.keys(actionCreators)</span><br><span class="line">  const boundActionCreators = &#123;&#125;</span><br><span class="line">  for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    const key = keys[i]</span><br><span class="line">    const actionCreator = actionCreators[key]</span><br><span class="line">    if (typeof actionCreator === &#x27;function&#x27;) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>compose接收一个函数数组，返回一个复合函数<br>解释：<br>例如：compose(f4,f3,f2,f1)(c,d,e)</p>
<ul>
<li>reduce回调函数第一次执行时，返回值为 函数 (…args) =&gt; f4(f3(…args))，作为下一次执行的参数a</li>
<li>回调函数第二次执行时，f2作为参数b，返回值为 函数(…args) =&gt; f4(f3(f2(…args))),作为下一次执行的参数a</li>
<li>回调函数第三次执行时，f1作为参数b，返回值为 函数(…args) =&gt; f4(f3(f2(f1(…args))))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default function compose(...funcs) &#123;</span><br><span class="line">  //没有传入函数参数，就返回一个默认函数（直接返回参数）</span><br><span class="line">  if (funcs.length === 0) &#123;</span><br><span class="line">    return (arg) =&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 单元素数组时调用reduce，会直接返回该元素，不会执行callback;所以这里手动执行</span><br><span class="line">  if (funcs.length === 1) &#123;</span><br><span class="line">    return funcs[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 依次拼凑执行函数</span><br><span class="line">  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>将原来的dispatch函数替换为会遍历执行所有middleware的新的dispatch函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 依次传入中间件</span><br><span class="line">// applyMiddleware(middlewares1, middlewares2, middlewares3)</span><br><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  // 返回一个函数，接收原来的createStore，随即有返回一个函数接收reducer和preloadedState</span><br><span class="line">  // enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</span><br><span class="line">    // 调用createStore创建store</span><br><span class="line">    const store = createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    // 保留原来的dispatch函数</span><br><span class="line">    let dispatch = store.dispatch</span><br><span class="line">    // 中间件执行链</span><br><span class="line">    let chain = []</span><br><span class="line"></span><br><span class="line">    // 中间件所需的参数</span><br><span class="line">    const middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    // 将middlewareAPI传入每一个中间件并执行返回，</span><br><span class="line">    // 中间形式：</span><br><span class="line">    /**</span><br><span class="line">     *  (&#123; dispatch, getState &#125;) =&gt; next =&gt; (action) =&gt; &#123;</span><br><span class="line">          if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">            return action(dispatch, getState, extraArgument);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return next(action);</span><br><span class="line">        &#125;;</span><br><span class="line">     */</span><br><span class="line">    // 执行之后返回的形式如 middleware：</span><br><span class="line">    /** next =&gt; (action) =&gt; &#123;</span><br><span class="line">      if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">        return action(dispatch, getState, extraArgument);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">  */</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">    // 调用compose函数，将中间件构造成一个执行链，并赋值为新的dispatch函数</span><br><span class="line">    // chain = [middleware1,middleware2,middleware3]</span><br><span class="line">    // dispatch = middlewares1(middlewares2(middlewares3(store.dispatch)))</span><br><span class="line">    // dispatch(action) = middlewares1(middlewares2(middlewares3(store.dispatch)))(action)</span><br><span class="line">    // 对于每一个chain中的next即为执行链中的中间件</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    // 新的createStore的返回值，其实唯一变化的就是dispatch字段。</span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><p><code>applyMiddleware(mid1, mid2, mid3, mid4)</code> 最终调用mid1(mid2(mid3(mid4(dispatch))))(action)<br>mid1中的next为mid2，mid2中的next为mid3，以此类推</p>
<ul>
<li>中间件会返回一个复合函数</li>
<li>返回的这个函数接收老的dispatch函数作为参数(也就是代码中的next)，会返回一个新的函数,在redux的applyMiddleware代码中将老的dispatch传入<code>dispatch = compose(...chain)(store.dispatch)</code></li>
<li>新函数就是新的dispatch函数，这个函数里面可以拿到外面两层传进来的getState和老dispatch函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; (action) =&gt; &#123;</span><br><span class="line">    if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-22/%E6%89%8B%E5%86%99%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-22/%E6%89%8B%E5%86%99%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">手写模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 16:15:35" itemprop="dateCreated datePublished" datetime="2022-02-22T16:15:35+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-28 14:34:33" itemprop="dateModified" datetime="2022-02-28T14:34:33+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="手写模块"><a href="#手写模块" class="headerlink" title="手写模块"></a>手写模块</h1><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>柯里化就是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b, c) &#123;</span><br><span class="line">    console.log(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toCurry(func, ...args) &#123;</span><br><span class="line">  // ↑需要柯里化的函数作为参数</span><br><span class="line">  // ↑也可以有初始参数传入</span><br><span class="line">  // ↑缓存在args中</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 合并上一次缓存的参数和本次传入的参数</span><br><span class="line">    args = [...args, ...arguments];</span><br><span class="line">    // 判断参数数量是否足够</span><br><span class="line">    if (args.length &lt; func.length) &#123;</span><br><span class="line">      // 如果不够，继续递归</span><br><span class="line">      // 注意，这里每一次递归都会形成新的闭包</span><br><span class="line">      // 保证柯里化函数每一步调用都是独立的，互不影响</span><br><span class="line">      return toCurry(func, ...args);</span><br><span class="line">    &#125; else</span><br><span class="line">      // 如果参数满足数量，执行函数并返回结果</span><br><span class="line">      return func.apply(null, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = toCurry(sum)</span><br><span class="line">f(1)(2)(3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function toCurry() &#123;</span><br><span class="line">  var args = Array.prototype.slice.call(arguments);</span><br><span class="line">  var fn = function () &#123;</span><br><span class="line">    var newArgs = args.concat(Array.prototype.slice.call(arguments));</span><br><span class="line">    return toCurry.apply(this, newArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  fn.toString = function () &#123;</span><br><span class="line">    return args.reduce(function (a, b) &#123;</span><br><span class="line">      return a * b;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1)(2)(3).toString()</span><br></pre></td></tr></table></figure>
<p>反柯里化：<br>遍历参数，然后调用柯里化函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function uncurrying(fn) &#123;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    var ret = fn; //柯里化函数</span><br><span class="line">    for (let i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">      ret = ret(args[i]); // 反复调用currying版本的函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret; // 返回结果</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写clone"><a href="#手写clone" class="headerlink" title="手写clone"></a>手写clone</h2><p>JSON.parse(JSON.stringify)的弊端：</p>
<ul>
<li>取不到值为 undefined或者函数 的 key</li>
<li>key为Symbol() 的属性会丢失</li>
<li>对象的原型会丢失，无法获取原型上的属性</li>
<li>NaN 和 无穷大，无穷小转变为 null</li>
<li>循环引用会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function clone(target, map = new WeakMap()) &#123;</span><br><span class="line">  if (typeof target === &#x27;object&#x27;) &#123;</span><br><span class="line">    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    if (map.get(target)) &#123;</span><br><span class="line">      return map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line">    for (const key in target) &#123;</span><br><span class="line">      cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="手写flat，数组扁平化"><a href="#手写flat，数组扁平化" class="headerlink" title="手写flat，数组扁平化"></a>手写flat，数组扁平化</h2><p>forEach(), filter(), reduce(), every() 和 some() 都会跳过空位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 全部展开</span><br><span class="line">function myFlat(arr, num = 1) &#123;</span><br><span class="line">  var result = [];</span><br><span class="line">  arr.forEach(item =&gt; &#123;</span><br><span class="line">    // 如果元素还是数组，则递归展开</span><br><span class="line">    if (Array.isArray(item) &amp;&amp; num &gt; 0) &#123;</span><br><span class="line">      result = result.concat(arguments.callee(item, num - 1))</span><br><span class="line">      // 或者使用扩展运算符</span><br><span class="line">      // arrResult.push(...arguments.callee(item));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用reduce</span><br><span class="line">function myFlat(arr) &#123;</span><br><span class="line">  return arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    return pre.concat(Array.isArray(cur) ? myFlat(cur) : cur);</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 传入层级函数</span><br><span class="line">function myFlat(arr, num = 1) &#123;</span><br><span class="line">  return num &gt; 0 ? arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    return pre.concat(Array.isArray(cur) ? myFlat(cur, num - 1) : cur);</span><br><span class="line">  &#125;, []) : [].concat(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用栈的方式</span><br><span class="line">function myFlat(arr, num = 1) &#123;</span><br><span class="line">  // 先将原数组入栈</span><br><span class="line">  const stack = [].concat(arr)</span><br><span class="line">  const result = []</span><br><span class="line">  while (stack.length !== 0) &#123;</span><br><span class="line">    // 获取栈顶元素</span><br><span class="line">    const item = stack.pop();</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">      // 如果栈顶的元素还是数组，则将数组再次入栈</span><br><span class="line">      stack.push(...item)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 每一次将元素都放在结果数组的最前面</span><br><span class="line">      result.unshift(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写reduce"><a href="#手写reduce" class="headerlink" title="手写reduce"></a>手写reduce</h2><p>语法：<br>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>
<ul>
<li>callback：执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数<ul>
<li>accumulator 累计器，是上一次调用回调时返回的累积值，或initialValue</li>
<li>currentValue： 当前值</li>
<li>index: 当前索引</li>
<li>array: 源数组</li>
</ul>
</li>
<li>initialValue：初始值，默认为数组的第一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//简单版</span><br><span class="line">function myReduce(arr, func, initValue) &#123;</span><br><span class="line">  // 处理回调类型异常 必须是函数</span><br><span class="line">  if (Object.prototype.toString.call(func) != &quot;[object Function]&quot;) &#123;</span><br><span class="line">    throw new TypeError(func + &quot; is not a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 空数组不操作</span><br><span class="line">  if (arr.length &lt;= 0) &#123;</span><br><span class="line">    return arr</span><br><span class="line">  &#125;</span><br><span class="line">  var num = initValue === undefined ? arr[0] : 0;</span><br><span class="line">  var startIndex = initValue === undefined ? 0 : 1;</span><br><span class="line"></span><br><span class="line">  for (var i = startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num = func(num, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//挂载在原型上</span><br><span class="line">Array.prototype.myReduce = function (func, initialValue) &#123;</span><br><span class="line">  // 处理回调类型异常 必须是函数</span><br><span class="line">  if (Object.prototype.toString.call(func) != &quot;[object Function]&quot;) &#123;</span><br><span class="line">    throw new TypeError(func + &quot; is not a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 空数组不操作</span><br><span class="line">  if (this.length &lt;= 0) &#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var num = initialValue || this[0];</span><br><span class="line">  var startIndex = initialValue ? 0 : 1;</span><br><span class="line"></span><br><span class="line">  for (var i = startIndex; i &lt; this.length; i++) &#123;</span><br><span class="line">    num = func(num, this[i], i, this);</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>触发事件后n秒后才执行函数，如果在n秒内触发了事件，则会重新计算函数执行时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line"></span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    var debounced = function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>连续触发事件但在n秒内只执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var later = function() &#123;</span><br><span class="line">        previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class="line">        timeout = null;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        if (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled = function() &#123;</span><br><span class="line">        var now = new Date().getTime();</span><br><span class="line">        if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">        var remaining = wait - (now - previous);</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            if (!timeout) context = args = null;</span><br><span class="line">        &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    throttled.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = 0;</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写-call-apply-bind-new"><a href="#手写-call-apply-bind-new" class="headerlink" title="手写 call/apply/bind/new"></a>手写 call/apply/bind/new</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;ljt&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line"></span><br><span class="line">  sayHello: function (prefix = &#x27;&#x27;) &#123;</span><br><span class="line">    console.log(prefix + &#x27;--&gt;&#x27; + this.name + &quot;:&quot; + this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;cdw&#x27;,</span><br><span class="line">    age: 29,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHello(&#x27;hz&#x27;)</span><br><span class="line">// hz--&gt;ljt:30</span><br><span class="line"></span><br><span class="line">person.sayHello.call(obj,&#x27;hn&#x27;)</span><br><span class="line">// hn--&gt;cdw:20</span><br></pre></td></tr></table></figure>

<p>手写call：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function (context) &#123;</span><br><span class="line">  const obj = (typeof context === &quot;object&quot;) ? context : window</span><br><span class="line">  // 防止覆盖掉原有属性</span><br><span class="line">  const key = Symbol()</span><br><span class="line"></span><br><span class="line">  // 这里的this为需要执行的方法</span><br><span class="line">  obj[key] = this;</span><br><span class="line"></span><br><span class="line">  // 获取剩余参数</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line"></span><br><span class="line">  // 方法执行</span><br><span class="line">  const result = obj[key](args)</span><br><span class="line"></span><br><span class="line">  //删除对象中的方法</span><br><span class="line">  delete obj[key]</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply函数和call函数类似，只是apply的参数是通过数组来传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;ljt&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line"></span><br><span class="line">  sayHello: function (prefix = &#x27;&#x27;) &#123;</span><br><span class="line">    console.log(prefix + &#x27;--&gt;&#x27; + this.name + &quot;:&quot; + this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;cdw&#x27;,</span><br><span class="line">    age: 29,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHello(&#x27;hz&#x27;)</span><br><span class="line">// hz--&gt;ljt:30</span><br><span class="line"></span><br><span class="line">person.sayHello.apply(obj,[&#x27;hn&#x27;])</span><br><span class="line">// hn--&gt;cdw:20</span><br></pre></td></tr></table></figure>

<p>apply实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function (context) &#123;</span><br><span class="line">  const obj = (typeof context === &quot;object&quot;) ? context : window</span><br><span class="line">  // 防止覆盖掉原有属性</span><br><span class="line">  const key = Symbol()</span><br><span class="line"></span><br><span class="line">  // 这里的this为需要执行的方法</span><br><span class="line">  obj[key] = this;</span><br><span class="line"></span><br><span class="line">  // 获取剩余参数</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  // 方法执行</span><br><span class="line">  // 注意这里和call不相同，需要把参数展开</span><br><span class="line">  const result = obj[key](...args)</span><br><span class="line"></span><br><span class="line">  //删除对象中的方法</span><br><span class="line">  delete obj[key]</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;ljt&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line"></span><br><span class="line">  sayHello: function (prefix = &#x27;&#x27;) &#123;</span><br><span class="line">    console.log(prefix + &#x27;--&gt;&#x27; + this.name + &quot;:&quot; + this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;cdw&#x27;,</span><br><span class="line">    age: 29,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHello(&#x27;hz&#x27;)</span><br><span class="line">// hz--&gt;ljt:30</span><br><span class="line"></span><br><span class="line">const fn = person.sayHello.bind(obj)</span><br><span class="line">fn(&#x27;hn&#x27;)</span><br><span class="line">// hn--&gt;cdw:20</span><br></pre></td></tr></table></figure>

<p>bind实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&#x27;mac this&#x27;, this);</span><br><span class="line">  self = this;</span><br><span class="line"></span><br><span class="line">  // 获取该方法剩余参数</span><br><span class="line">  const args = [...arguments].slice(1);</span><br><span class="line"></span><br><span class="line">  // 设置返回的一个新方法</span><br><span class="line">  const result = function () &#123;</span><br><span class="line"></span><br><span class="line">    // 获取返回方法体的参数</span><br><span class="line">    const resultArgs = [...arguments];</span><br><span class="line">    // 如果是通过 new 调用的，绑定 this 为实例对象</span><br><span class="line">    if (this instanceof result) &#123;</span><br><span class="line">      self.apply(this, args.concat(resultArg));</span><br><span class="line">    &#125; else &#123; // 否则普通函数形式绑定 context</span><br><span class="line">      self.apply(context, args.concat(resultArg));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 绑定原型链</span><br><span class="line"></span><br><span class="line">  // 如果这样写 result.prototype = this.prototype</span><br><span class="line">  // 重写了默认的 prototype 对象，因此其 constructor 属性也指向了完全不同 的新对象(Object 构造函数)，不再指向原来的构造函数</span><br><span class="line">  // 原型式继承</span><br><span class="line">  function object(o) &#123;</span><br><span class="line">      function F() &#123;&#125;</span><br><span class="line">      F.prototype = o;</span><br><span class="line">      return new F();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result.prototype = Object.create(this.prototype);</span><br><span class="line"></span><br><span class="line">  // 返回结果</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new的主要操作：</p>
<ul>
<li>1、创建一个新的对象</li>
<li>2、将想的对象的__proto__执行构造函数的prototype对象</li>
<li>3、构造函数的this被赋值为这个新对象</li>
<li>4、执行构造函数的内部代码，为这个新对象增加属性</li>
<li>5、如果构造函数返回非空对象，则返回这个非空对象，否则返回新创建的对象<br>方式一：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function _new(obj, ...rest) &#123;</span><br><span class="line">  // 基于obj的原型创建一个新的对象</span><br><span class="line">  const newObj = Object.create(obj.prototype);</span><br><span class="line"></span><br><span class="line">  // 添加属性到新创建的newObj上, 并获取obj函数执行的结果.</span><br><span class="line">  const result = obj.apply(newObj, rest);</span><br><span class="line"></span><br><span class="line">  // 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象</span><br><span class="line">  return typeof result === &#x27;object&#x27; ? result : newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>方式二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function _new() &#123;</span><br><span class="line">  const obj = new Object();</span><br><span class="line">  // arguments第一个值是构造函数</span><br><span class="line">  constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">  obj.__proto__ = constructor.prototype;</span><br><span class="line">  constructor.apply(obj, arguments);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-17/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-17/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">JS的类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-17 16:28:48 / 修改时间：16:29:07" itemprop="dateCreated datePublished" datetime="2022-02-17T16:28:48+08:00">2022-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JS的类型转换"><a href="#JS的类型转换" class="headerlink" title="JS的类型转换"></a>JS的类型转换</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul>
<li>当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型</li>
<li>当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型</li>
<li>当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接<h3 id="减、乘、除"><a href="#减、乘、除" class="headerlink" title="减、乘、除"></a>减、乘、除</h3>我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - true // 0， 首先把 true 转换为数字 1， 然后执行 1 - 1</span><br><span class="line">1 - null // 1,  首先把 null 转换为数字 0， 然后执行 1 - 0</span><br><span class="line">1 * undefined //  NaN, undefined 转换为数字是 NaN</span><br><span class="line">2 * [&#x27;5&#x27;] //  10， [&#x27;5&#x27;]首先会变成 &#x27;5&#x27;, 然后再变成数字 5</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用-比较中的5条规则"><a href="#使用-比较中的5条规则" class="headerlink" title="使用 == 比较中的5条规则"></a>使用 == 比较中的5条规则</h3><ul>
<li><p>规则 1：NaN和其他任何类型比较永远返回false（包括和他自己</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN // false</span><br></pre></td></tr></table></figure></li>
<li><p>规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true == 1  // true</span><br><span class="line">true == &#x27;2&#x27;  // false, 先把 true 变成 1，而不是把 &#x27;2&#x27; 变成 true</span><br><span class="line">true == [&#x27;1&#x27;]  // true, 先把 true 变成 1， [&#x27;1&#x27;]拆箱成 &#x27;1&#x27;, 再参考规则3</span><br><span class="line">true == [&#x27;2&#x27;]  // false, 同上</span><br><span class="line">undefined == false // false ，首先 false 变成 0，然后参考规则4</span><br><span class="line">null == false // false，同上</span><br></pre></td></tr></table></figure></li>
<li><p>规则 3：String和Number比较，先将String转换为Number类型</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123 == &#x27;123&#x27; // true, &#x27;123&#x27; 会先变成 123</span><br><span class="line">&#x27;&#x27; == 0 // true, &#x27;&#x27; 会首先变成 0</span><br></pre></td></tr></table></figure></li>
<li><p>规则 4：null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">null == undefined // true</span><br><span class="line">null == &#x27;&#x27; // false</span><br><span class="line">null == 0 // false</span><br><span class="line">null == false // false</span><br><span class="line">undefined == &#x27;&#x27; // false</span><br><span class="line">undefined == 0 // false</span><br><span class="line">undefined == false // false</span><br></pre></td></tr></table></figure></li>
<li><p>规则 5： 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型。</p>
<ul>
<li>ToPrimitive规则，是引用类型向原始类型转变的规则，它遵循先valueOf后toString的模式期望得到一个原始类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;[object Object]&#x27; == &#123;&#125;</span><br><span class="line">// true, 对象和字符串比较，对象通过 toString 得到一个基本类型值</span><br><span class="line">&#x27;1,2,3&#x27; == [1, 2, 3]</span><br><span class="line">// true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-17/React%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-17/React%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">React知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-17 10:39:57" itemprop="dateCreated datePublished" datetime="2022-02-17T10:39:57+08:00">2022-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-13 15:54:55" itemprop="dateModified" datetime="2022-05-13T15:54:55+08:00">2022-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="React18新特性"><a href="#React18新特性" class="headerlink" title="React18新特性"></a>React18新特性</h2><h3 id="挂载root节点-Render-API"><a href="#挂载root节点-Render-API" class="headerlink" title="挂载root节点 Render API"></a>挂载root节点 Render API</h3><p>React18为了更好的管理root节点，引入了新的root API，新的 root API 支持 new concurrent renderer（并发模式的渲染）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// before</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;;</span><br><span class="line"></span><br><span class="line">const root = document.getElementById(&#x27;root&#x27;)!;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;, root);</span><br><span class="line"></span><br><span class="line">// React 18</span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom/client&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;;</span><br><span class="line"></span><br><span class="line">const root = document.getElementById(&#x27;root&#x27;)!;</span><br><span class="line"></span><br><span class="line">ReactDOM.createRoot(root).render(&lt;App /&gt;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">// 服务端渲染</span><br><span class="line">// before</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">const root = document.getElementById(&#x27;root&#x27;);</span><br><span class="line">ReactDOM.hydrate(&lt;App /&gt;, root);</span><br><span class="line"></span><br><span class="line">// React 18</span><br><span class="line">import ReactDOM from &#x27;react-dom/client&#x27;;</span><br><span class="line">const root = document.getElementById(&#x27;root&#x27;)!;</span><br><span class="line">ReactDOM.hydrateRoot(root, &lt;App /&gt;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="卸载根节点"><a href="#卸载根节点" class="headerlink" title="卸载根节点"></a>卸载根节点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// before</span><br><span class="line">ReactDOM.unmountComponentAtNode(root);</span><br><span class="line"></span><br><span class="line">// React 18</span><br><span class="line">root.unmount();</span><br></pre></td></tr></table></figure>

<h3 id="setState-自动批处理"><a href="#setState-自动批处理" class="headerlink" title="setState 自动批处理"></a>setState 自动批处理</h3><p>React 18 通过在默认情况下执行批处理来实现了开箱即用的性能改进,将多个状态更新批量处理，合并成一次更新（在视图层，将多个渲染合并成一次渲染）</p>
<p>在React18之前：</p>
<p>只会在React的事件处理中自动合并更新（批量处理），在<code>promise</code>、<code>setTimeout</code>、<code>原生事件处理函数中</code>、或<code>任何其它事件</code>内的更新都不会进行批处.</p>
<ol>
<li>React事件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;App组件渲染了！&#x27;);</span><br><span class="line">  const [count1, setCount1] = useState(0);</span><br><span class="line">  const [count2, setCount2] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;button</span><br><span class="line">      // React事件 setState被批处理</span><br><span class="line">      // 组件只会重新渲染1次</span><br><span class="line">      onClick=&#123;() =&gt; &#123;</span><br><span class="line">        setCount1(count =&gt; count + 1);</span><br><span class="line">        setCount2(count =&gt; count + 1);</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;`count1 is $&#123;count1&#125;, count2 is $&#123;count2&#125;`&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li>
<li>setTimeout事件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;App组件渲染了！&#x27;);</span><br><span class="line">  const [count1, setCount1] = useState(0);</span><br><span class="line">  const [count2, setCount2] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      onClick=&#123;() =&gt; &#123;</span><br><span class="line">        // setState被setTimeout包括，不会进行批处理</span><br><span class="line">        // 组件会连续渲染两次</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          setCount1(count =&gt; count + 1);</span><br><span class="line">          setCount2(count =&gt; count + 1);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;div&gt;count1： &#123;count1&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;count2： &#123;count2&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li>
<li>原生JS事件 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useEffect, useState &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;App组件渲染了！&#x27;);</span><br><span class="line">  const [count1, setCount1] = useState(0);</span><br><span class="line">  const [count2, setCount2] = useState(0);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // setState在原生js事件中,不会进行批处理</span><br><span class="line">    // 组件会连续渲染两次</span><br><span class="line">    document.body.addEventListener(&#x27;click&#x27;, () =&gt; &#123;</span><br><span class="line">      setCount1(count =&gt; count + 1);</span><br><span class="line">      setCount2(count =&gt; count + 1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;count1： &#123;count1&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;count2： &#123;count2&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>React18中，上述情况会自动被批量处理</p>
<p>如果你想退出批量更新，你可以使用 flushSync：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; flushSync &#125; from &#x27;react-dom&#x27;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;App组件渲染了！&#x27;);</span><br><span class="line">  const [count1, setCount1] = useState(0);</span><br><span class="line">  const [count2, setCount2] = useState(0);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div</span><br><span class="line">      onClick=&#123;() =&gt; &#123;</span><br><span class="line">        flushSync(() =&gt; &#123;</span><br><span class="line">          setCount1(count =&gt; count + 1);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 第一次更新</span><br><span class="line">        flushSync(() =&gt; &#123;</span><br><span class="line">          setCount2(count =&gt; count + 1);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 第二次更新</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;div&gt;count1： &#123;count1&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;count2： &#123;count2&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h3 id="React-组件的返回值"><a href="#React-组件的返回值" class="headerlink" title="React 组件的返回值"></a>React 组件的返回值</h3><p>之前：如果你需要返回一个空组件，React只允许返回null。如果你显式的返回了 undefined，控制台则会在运行时抛出一个错误</p>
<p>React18：不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefined：（但是 React 18 的dts文件还是会检查，只允许返回 null，你可以忽略这个类型错误）。</p>
<h3 id="Suspense-不再需要-fallback-来捕获"><a href="#Suspense-不再需要-fallback-来捕获" class="headerlink" title="Suspense 不再需要 fallback 来捕获"></a>Suspense 不再需要 fallback 来捕获</h3><p>React18 的 Suspense 组件中，不再跳过<code>缺失值</code>或<code>值为null</code>的 fallback 的Suspense边界。相反，会捕获边界并且向外层查找，如果查找不到，将会把 fallback呈现为null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// before</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; // &lt;--- 这个边界被使用，显示 Loading 组件</span><br><span class="line">      &lt;Suspense&gt;                      // &lt;--- 这个边界被跳过，没有 fallback 属性</span><br><span class="line">        &lt;Page /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line"></span><br><span class="line">// React 18</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; // &lt;--- 不使用</span><br><span class="line">      &lt;Suspense&gt;                      // &lt;--- 这个边界被使用，将 fallback 渲染为 null</span><br><span class="line">        &lt;Page /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Concurrent-Mode（并发模式）"><a href="#Concurrent-Mode（并发模式）" class="headerlink" title="Concurrent Mode（并发模式）"></a>Concurrent Mode（并发模式）</h3><p>在 React18 中，提供了新的 root api，把 render 升级成 createRoot(root).render(<App />) 就可以开启并发模式,但是开启并发模式并没有开启并发更新，启用并发更新需要借助连个API：</p>
<ul>
<li><p>useTransition</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect, useTransition &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  const [list, setList] = useState&lt;any[]&gt;([]);</span><br><span class="line">  const [isPending, startTransition] = useTransition();</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 使用了并发特性，开启并发更新</span><br><span class="line">    startTransition(() =&gt; &#123;</span><br><span class="line">      setList(new Array(10000).fill(null));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;list.map((_, i) =&gt; (</span><br><span class="line">        &lt;div key=&#123;i&#125;&gt;&#123;i&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></li>
<li><p>useDeferredValue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect, useDeferredValue &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const App: React.FC = () =&gt; &#123;</span><br><span class="line">  const [list, setList] = useState&lt;any[]&gt;([]);</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    setList(new Array(10000).fill(null));</span><br><span class="line">  &#125;, []);</span><br><span class="line">  // 使用了并发特性，开启并发更新</span><br><span class="line">  const deferredList = useDeferredValue(list);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;deferredList.map((_, i) =&gt; (</span><br><span class="line">        &lt;div key=&#123;i&#125;&gt;&#123;i&#125;&lt;/div&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<p>useDeferredValue 和 startTransition 一样，都是标记了一次非紧急更新,此时我们的任务被拆分到每一帧不同的 task 中，JS脚本执行时间大体在5ms左右，这样浏览器就有剩余时间执行样式布局和样式绘制，减少掉帧的可能性.</p>
</li>
<li><p>相同：useDeferredValue 本质上和内部实现与 useTransition 一样，都是标记成了延迟更新任务。</p>
</li>
<li><p>不同：useTransition 是把更新任务变成了延迟更新任务，而 useDeferredValue 是产生一个新的值，这个值作为延时状态。（一个用来包装方法，一个用来包装值）</p>
</li>
</ul>
<h3 id="关于卸载组件时的更新状态警告"><a href="#关于卸载组件时的更新状态警告" class="headerlink" title="关于卸载组件时的更新状态警告"></a>关于卸载组件时的更新状态警告</h3><p>React18删除了<strong>无法对未挂载（已卸载）的组件执行状态更新</strong>的警告信息<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/59.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-10/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-10/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/" class="post-title-link" itemprop="url">webpack热更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-10 09:43:53" itemprop="dateCreated datePublished" datetime="2022-02-10T09:43:53+08:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-17 09:44:36" itemprop="dateModified" datetime="2022-02-17T09:44:36+08:00">2022-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="webpack热更新-HMR"><a href="#webpack热更新-HMR" class="headerlink" title="webpack热更新 HMR"></a>webpack热更新 HMR</h1><p>Webpack热更新（ Hot Module Replacement，简称 HMR），可以使开发者无需完全刷新整个页面的同时，更新所有类型的模块，是 Webpack 提供的最有用的功能之一。<br>HMR作为一个webpack内置的功能，可以通过HotModuleReplacementPlugin或–hot开启</p>
<h2 id="webpack热更新的原理"><a href="#webpack热更新的原理" class="headerlink" title="webpack热更新的原理"></a>webpack热更新的原理</h2><p>介绍webpack-dev-server:<br>webpack-dev-server 主要包含了三个部分：</p>
<ul>
<li>1.webpack: 负责编译代码</li>
<li>2.webpack-dev-middleware: 主要负责构建内存文件系统，把webpack的 OutputFileSystem 替换成 InMemoryFileSystem。同时作为Express的中间件拦截请求，从内存文件系统中把结果拿出来。</li>
<li>3.express：负责搭建请求路由服务</li>
</ul>
<p>详细过程</p>
<ul>
<li>1.启动dev-server，webpack开始构建、注册webpack编译完成事件回调，启动本地HTTP静态资源服务，Client和Server之间建立一个 websocket 长连接</li>
<li>2.webpack-dev-middleware中间件将文件系统设置为内存文件系统，并监听文件的变化</li>
<li>3.修改文件，Server端watch监听文件发送变动，webpack开始编译，直到编译完成会触发”Done”事件；</li>
<li>4.Server通过socket 发送消息告知 Client；</li>
<li>5.Client根据Server的消息（hash值和state状态），向webpack发送webpackHotUpdate事件</li>
<li>6、webpack会监听webpackHotUpdate事件调用调用module.hot.check方法进行热更新。</li>
<li>7、通过ajax请求获取 Server 的manifest描述文件，获取服务器这一次编译相对于上一次编译改变了哪些module和chunk</li>
<li>8.通过JSONP请求获取到最新的模块代码</li>
<li>9.Client获取到新的JS模块后，进行模块热更新；</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/hot-module-replacement">官方文档</a><br><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/118">介绍下 webpack 热更新原理</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020310371">彻底搞懂并实现webpack热更新原理</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904008432222215">轻松理解webpack热更新原理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-09/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ljt">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJT的杂货铺">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-09/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/" class="post-title-link" itemprop="url">发布一个npm包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-09 16:16:35" itemprop="dateCreated datePublished" datetime="2022-02-09T16:16:35+08:00">2022-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-16 17:48:09" itemprop="dateModified" datetime="2022-02-16T17:48:09+08:00">2022-02-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NPM库制作"><a href="#NPM库制作" class="headerlink" title="NPM库制作"></a>NPM库制作</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1、注册账号 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a><br>2、本机Node环境<br>3、实现功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">制作一个lib包，实现输入一个名字，然后将名字全部小写，并输出：hello! ljt 2022-02-15 12:24:37</span><br><span class="line">比如输入cdw或者cdW hello! cdw 2022-02-15 12:24:37</span><br></pre></td></tr></table></figure>

<h2 id="简单的NPM包"><a href="#简单的NPM包" class="headerlink" title="简单的NPM包"></a>简单的NPM包</h2><p>第一步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;ljt-lib&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test包&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;test&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;ljt&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次输入相关的信息，形成package.json文件</p>
<p>第二步：<br>先导入所需的外部库，这里我们使用lodash和moment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash</span><br><span class="line">npm install moment</span><br></pre></td></tr></table></figure>
<p>执行以上两步后，会安转lodash和moment两个外部库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;ljt-lib&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test包&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;test&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;ljt&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  // 安装的第三方库</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;lodash&quot;: &quot;^4.17.21&quot;,</span><br><span class="line">    &quot;moment&quot;: &quot;^2.29.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：<br>编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; toLower &#125; = require(&quot;lodash&quot;)</span><br><span class="line">const moment = require(&#x27;moment&#x27;)</span><br><span class="line">function sayHello(name = &#x27;ljt&#x27;) &#123;</span><br><span class="line">  return &#x27;hello!&#x27; + &#x27; &#x27; + toLower(name) + &#x27; &#x27; + moment().format(&quot;YYYY-MM-DD HH:mm:ss&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  sayHello</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第四步：<br>将编写好的包发布至npm仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm login // 登录</span><br><span class="line">npm publish //发布</span><br><span class="line">npm unpublish ljt-lib --force //删除包</span><br></pre></td></tr></table></figure>

<p>第五步：<br>在项目中引用刚刚发布的包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install ljt-lib</span><br><span class="line"></span><br><span class="line">const &#123; sayHello &#125; = require(ljt-lib)</span><br><span class="line">const hello = sayHello(&#x27;CDW)</span><br><span class="line">console.log(hello)</span><br></pre></td></tr></table></figure>

<p>第六步：<br>如果需要更新包，则需要修改package.json中的version字段，然后重新发布</p>
<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><h3 id="package-json中dependencies和devDependencies的区别"><a href="#package-json中dependencies和devDependencies的区别" class="headerlink" title="package.json中dependencies和devDependencies的区别"></a>package.json中<code>dependencies</code>和<code>devDependencies</code>的区别</h3><p>dependencies：生产环境所需要依赖，例如：Vue，React 等，如果缺少依赖项目就运行错误<br>devDependencies:字面意思就是开发依赖，开发时候才会用到的工具包，例如：webpack，eslint等，等项目上线后不需依赖相关代码运行的工具</p>
<p>单单从概念上理解会比较难，我们从两方面来理解：</p>
<ul>
<li><p>第一、在项目中<br>我们在开发项目中，我们一般使用<code>npm install &lt;package&gt;</code>或<code>npm install &lt;package&gt; --save-dev</code>来分别安装dependencies和devDependencies，这个时候会把包都安装在node_modules文件夹下，同时会生成一个<code>package-lock.json</code>文件。如果第三个使用这个项目的源码，执行<code>npm install</code>，则会安装所有的依赖。打包的时候不管你的依赖是在<code>dependencies</code>中，还是<code>devDependencies</code>中都会打包进去。以webpack为例，从入口文件开始构建依赖树，如果你的代码中引用了某个依赖就会被打包进进去。<br>这个时候安转在哪里其实没有什么区别，可以看作成一个规范和约束</p>
</li>
<li><p>第二、NPM库中<br>如果在制作NPM库中，这两个字段的差异就比较大了，当别人使用制作好的NPM包时<code>npm install &lt;package&gt;</code>，只会安装<code>dependencies</code>中的依赖，而不会去下载<code>devDependencies</code>中的依赖。如果将开发相关的依赖放到了<code>dependencies</code>依赖中，比如把<code>jest</code>放入到<code>dependencies</code>依赖，那么就会下载<code>jest</code>到别人的项目中，无形中增加了项目的体积。</p>
</li>
</ul>
<p>除了<code>dependencies</code>和<code>devDependencies</code>这两个依赖相关的字段还有其他几个字段</p>
<ul>
<li>peerDependencies 同等依赖，或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本.</li>
<li>optionalDependencies 可选依赖，如果有一些依赖包即使安装失败，项目仍然能够运行或者希望npm继续运行，就可以使用optionalDependencies</li>
<li>bundledDependencies 作者希望以压缩包（tar.gz）的方式发布项目，即没有 publish 到 npm register 上的包 这个字段不常用</li>
</ul>
<h2 id="增加webpack打包机制"><a href="#增加webpack打包机制" class="headerlink" title="增加webpack打包机制"></a>增加webpack打包机制</h2><p>第一步制作的NPM包有几个局限，使用了commonjs规范、无法使用ES6语法、无法减小包的体积等。如果使用webpack打包，则可以解决上述问题。</p>
<ul>
<li><p>先修改一下原先项目的目录<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/55.png" alt="avatar"><br>lib文件夹下放打包好的文件</p>
</li>
<li><p>使用es6语法编写代码</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">const sayHello = (name) =&gt; &#123;</span><br><span class="line">  return &#x27;hello!&#x27; + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; sayHello &#125;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">import &#123; sayHello &#125; from &#x27;./module&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改package.json文件,具体修改看注释</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;ljt-lib&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.16&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test包&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;lib/main.js&quot;, //指定包的入口，即第三方安装后由这里加载</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;, // 增加webpack打包命令</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;test&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;lib/*.js&quot; // 指定那些文件会被上传至NPM库中</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;ljt&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^5.69.0&quot;, // webpack相关依赖</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^4.9.2&quot; // webpack相关依赖</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增加webpack.config.js配置文件,这个配置文件需要特别关注<code>libraryTarget: &#39;umd&#39;,</code>，这里表示要将这个lib包以什么规范来打包，也就是第三方能够已何种方式来使用（script标签/umd、npm安装包/commonjs）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;none&#x27;,</span><br><span class="line">  entry: &#x27;./index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#x27;lib&#x27;),</span><br><span class="line">    filename: &quot;[name].js&quot;,</span><br><span class="line">    libraryTarget: &#x27;umd&#x27;,</span><br><span class="line">    clean: true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>npm run build</code>编译无误后，按照第一部分的步骤发布即可</p>
<h2 id="移除外部模块"><a href="#移除外部模块" class="headerlink" title="移除外部模块"></a>移除外部模块</h2><p>这个怎么理解呢，就是如果你在自己的包中使用了另一个第三方包，比如<code>lodash</code>,假如不做处理，你的build后的包的体积会很大，因为引入了<code>lodash</code>，这时我们可以将<code>lodash</code>排除在webpack打包之外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#x27;lib&#x27;),</span><br><span class="line">    filename: &quot;[name].js&quot;,</span><br><span class="line">    libraryTarget: &#x27;umd&#x27;,</span><br><span class="line">    clean: true</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: &#123;</span><br><span class="line">    lodash: &#x27;lodash&#x27;,</span><br><span class="line">    // lodash: &#123;</span><br><span class="line">    //   commonjs: &#x27;lodash&#x27;,</span><br><span class="line">    //   commonjs2: &#x27;lodash&#x27;,</span><br><span class="line">    //   amd: &#x27;lodash&#x27;,</span><br><span class="line">    //   root: &#x27;_&#x27;,</span><br><span class="line">    // &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="externals和libraryTarget"><a href="#externals和libraryTarget" class="headerlink" title="externals和libraryTarget"></a>externals和libraryTarget</h2><p>externals指定那些外部模块需要从打包后的bundle中移除，并且还指定了引入外部模块所加载的模式<br>libraryTarget指定以那种规范打包，同时也决定了以哪种模式去加载所引入的外部模块。也就是说，externals应该和libraryTarget保持一致。如果library运行在浏览器中的，你设置externals的模式为commonjs，那其实是运行不了的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ljt</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ljt</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
