<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hexo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-05-07/Ajax-Fetch-Axios%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-05-07/Ajax-Fetch-Axios%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">Ajax_Fetch_Axios三者的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-07 14:20:43 / 修改时间：14:21:59" itemprop="dateCreated datePublished" datetime="2022-05-07T14:20:43+08:00">2022-05-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>全称是：Asynchronous JavaScript And XML 即：“异步的JavaScript 和 XML”<br>Ajax是一个技术统称，是一个概念模型，他囊括了很多技术，并不特定指某一技术，他的一个重要特性就是实现界面的局部刷新。<br>简单的来说：Ajax是一种思想，XMLHttpRequest只是实现Ajax的一种方式</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios是一个网络请求库，利用XMLHttpRequst进行了二次封装的请求库，但是XMLHttpRequst只是axios中的其中一个请求适配器，还可以采用其他请求适配器</p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>Fetch是ES6出现的，他使用了ES6提出的promise对象，是XHLHttpRequest的替代品。<br>通常会拿他与Ajax做比较，严格来说这是不对的，我们通常所说的Ajax是指使用XMLHttpRequst实现的Ajax，所以真正应该是和XMLHttpRequst作比较。<br><code>Fetch 是一个 API，它是真实存在的，它是基于 promise 的。</code></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><table>
<thead>
<tr>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Ajax</td>
<td>一种技术统称，主要利用XHR实现网络请求</td>
</tr>
<tr>
<td>Axios</td>
<td>一个封装库</td>
</tr>
<tr>
<td>Fetch</td>
<td>具体API，基于promise，实现网络请求</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-04-19/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-04-19/JavaScript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JavaScript内存管理机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-19 14:35:43 / 修改时间：14:36:01" itemprop="dateCreated datePublished" datetime="2022-04-19T14:35:43+08:00">2022-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JavaScript内存管理机制</p>
<p>常用的GC算法</p>
<p>引用计数</p>
<p>没有引用指向该对象（零引用），对象将被垃圾回收机制回收<br>弊端：<br>无法处理循环引用的事例</p>
<p>标记-清除</p>
<p>垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p>
<p>标记-整理</p>
<p>标记清除有空间碎片化的缺点，标记整理是标记清除的增强。标记整理在标记阶段的操作和标记清除一致，但是在清除阶段会先执行整理，再进行清除。</p>
<p>V8引擎的分代回收策略</p>
<p>将内存分为新生代和旧生代两种，并对不同的对象采用不同的算法。</p>
<p>新生代内存</p>
<p>采用Scavenge算法进行垃圾回收，在具体实现中采用了Cheney算法。具体逻辑如下：</p>
<p>将新生代内存分为两个等大的空间，一个空间为From，一个空间为To<br>当我们分配对象时，先在From空间进行分配，当前活动的对象也存储在From空间中<br>当触发进行垃圾回收时，会检查From空间中的存活对象，将存活对象复制到To空间，非存活对象被自动回收<br>当复制完成之后From空间和To空间进行一次角色互换，即To空间会变为新的From空间，原来的From空间则变为To空间<br>对象晋升：<br>当一个对象在经历多次复制之后依旧存活，则会被认为是一个生命周期较长的对象，在下次进行垃圾回收时，该对象会被直接转移到老生代内存中，这种行为称为晋升。<br>对象是否经历过了一次Scavenge算法<br>To空间的内存占比是否已经超过25%<br>老生代内存</p>
<p>在老生代内存中，管理着大量的存活对象，主要采用标记清除算法和标记清理算法<br>标记清除算法主要进行垃圾对象回收<br>标记清理算法主要解决内存碎片问题<br>为了减少垃圾回收带来的停顿时间，V8引擎又引入了【增量标记】的概念，即将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。</p>
<p>增量标记法为什么能优化效率？<br>因为增量标记算法是将一整个的垃圾回收分为多个小的垃圾回收，这样就会使垃圾回收与程序的执行进行交替的工作，这样可以使时间上的消耗及程序停顿的时间更加的合理一些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-04-13/npm-run-xxx%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-04-13/npm-run-xxx%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">npm_run_xxx执行过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-13 14:07:54 / 修改时间：14:08:11" itemprop="dateCreated datePublished" datetime="2022-04-13T14:07:54+08:00">2022-04-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="npm-run-xxx执行过程"><a href="#npm-run-xxx执行过程" class="headerlink" title="npm run xxx执行过程"></a>npm run xxx执行过程</h1><h2 id="第一问-当输入npm-run-xxx时发生了什么？"><a href="#第一问-当输入npm-run-xxx时发生了什么？" class="headerlink" title="第一问 当输入npm run xxx时发生了什么？"></a>第一问 当输入npm run xxx时发生了什么？</h2><p>当输入npm run xxx时，首先回去package.json文件中寻找scripts字段里面对应的xxx命令，如果找到，然后执行，如果没有找到则报错<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;react-scripts test&quot;,</span><br><span class="line">    &quot;eject&quot;: &quot;react-scripts eject&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="第二问-为什么不直接执行-react-scripts-start（举例）"><a href="#第二问-为什么不直接执行-react-scripts-start（举例）" class="headerlink" title="第二问 为什么不直接执行 react-scripts start（举例）"></a>第二问 为什么不直接执行 react-scripts start（举例）</h2><p>因为直接执行react-scripts start会报错，因为系统中没有存在react-scripts start这一条指令</p>
<h2 id="第三问-为什么通过npm-run执行时却可以执行"><a href="#第三问-为什么通过npm-run执行时却可以执行" class="headerlink" title="第三问 为什么通过npm run执行时却可以执行"></a>第三问 为什么通过npm run执行时却可以执行</h2><p>安装依赖的时候，是通过npm i xxx 来执行的，例如 npm i xxx在安装这个依赖的时候，就会node_modules/.bin/ 目录中创建好react-script的执行文件，如图，.bin目录下的表示这是一个一个的软链接，链接到具体执行的脚本文件<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/56.png"><br>所以执行<code>npm run start</code>等于执行<code>./node_modules/.bin/react-scripts serve</code>，实际最后等于执行<code>../react-scripts/bin/react-scripts.js serve</code></p>
<h2 id="第四问-那这个软链接是什么时候，怎么创建的呢？"><a href="#第四问-那这个软链接是什么时候，怎么创建的呢？" class="headerlink" title="第四问 那这个软链接是什么时候，怎么创建的呢？"></a>第四问 那这个软链接是什么时候，怎么创建的呢？</h2><p>关键就在于react-script这个包的package.json中的bin字段<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/57.png"><br>在 npm i react-script 时，npm 读到该配置后，就将该文件软链接到 ./node_modules/.bin 目录下，而 npm 还会自动把node_modules/.bin加入$PATH，这样就可以直接作为命令运行依赖程序和开发依赖程序，不用全局安装了</p>
<h2 id="第五问-npm-install-g-xxx-安装会怎样"><a href="#第五问-npm-install-g-xxx-安装会怎样" class="headerlink" title="第五问  npm install -g xxx 安装会怎样"></a>第五问  npm install -g xxx 安装会怎样</h2><p>全局安装时，会将其中的 bin 文件加入到全局，比如 create-react-app 和 vue-cli ，在全局安装后，就可以直接使用如 vue-cli projectName 这样的命令来创建项目了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-03-11/Redux%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-03-11/Redux%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">Redux知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-11 10:15:23 / 修改时间：10:16:10" itemprop="dateCreated datePublished" datetime="2022-03-11T10:15:23+08:00">2022-03-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redux相关"><a href="#Redux相关" class="headerlink" title="Redux相关"></a>Redux相关</h1><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>导出redux所暴露的API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123;</span><br><span class="line">  createStore,</span><br><span class="line">  combineReducers,</span><br><span class="line">  bindActionCreators,</span><br><span class="line">  applyMiddleware,</span><br><span class="line">  compose</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p>创建redux所需的store数据对象，包含当前数据状态和修改数据状态的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 整个文件只导出一个函数，就是createStore函数。参数如下：</span><br><span class="line">// * reducer - 我们传入的reducer纯函数，用来定义我们的state可以做的操作，如果不懂它的概念可以参考上一篇文章</span><br><span class="line">// * preloadedState - state的初始化值</span><br><span class="line">// * enhancer - 当我们需要使用middleware的时候，会用到。</span><br><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  // 如果传入了第三方插件，则使用第三方插件来创建store</span><br><span class="line">  // 具体实现方式可参考applyMiddleware</span><br><span class="line">  if (typeof enhancer !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">    // 第三方插件</span><br><span class="line">    return enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 当前的reducer。Redux支持我们替换当前的reducer为另一个函数</span><br><span class="line">  let currentReducer = reducer</span><br><span class="line">  // 用来存储我们整个程序的状态</span><br><span class="line">  let currentState = preloadedState</span><br><span class="line">  // 状态监听函数，当状态发生改变的时候会被调用。可以注册多个监听函数。</span><br><span class="line">  let currentListeners = []</span><br><span class="line">  // 这个是为了处理一些异常情况而保存一份currentListeners的shallow copy副本，不影响核心逻辑的理解，可以暂时忽略</span><br><span class="line">  let nextListeners = currentListeners</span><br><span class="line"></span><br><span class="line">  // 提供给外部调用，用来获取当前state。由于state是Redux的内部变量，外部只能通过API函数来获取状态。</span><br><span class="line">  function getState() &#123;</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 注册监听器，listener是回调函数，当状态被修改的时候调用</span><br><span class="line">  function subscribe(listener) &#123;</span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">      const index = nextListeners.indexOf(listener)</span><br><span class="line">      nextlisteners.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // dispatch用来修改一个状态</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching = true</span><br><span class="line">      // 调用当前的reducer，传入当前状态和action，然后将返回值更新为新状态</span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching = false</span><br><span class="line">    &#125;</span><br><span class="line">    // 依次调用监听器函数</span><br><span class="line">    const listeners = (currentListeners = nextListeners)</span><br><span class="line">    for (let i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      const listener = listeners[i]</span><br><span class="line">      listener()</span><br><span class="line">    &#125;</span><br><span class="line">    return action</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 更换reducer函数</span><br><span class="line">  function replaceReducer(nextReducer) &#123;</span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.REPLACE &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // dispatch一个INIT事件，外部可以监听这个事件，用于一些初始化的工作</span><br><span class="line">  dispatch(&#123; type: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line">  // 返回值是一个对象，包含了用于获取和操作状态的函数</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p>将多个reducer合并为一个总的reducer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 整个文件导出一个函数</span><br><span class="line">// 参数reducers是一个Object，比如一个todo app可能包含users和todos两部分数据，</span><br><span class="line">// 那么它的格式如下：</span><br><span class="line">// &#123;</span><br><span class="line">//    users: function userReducer()&#123;&#125;,</span><br><span class="line">//    todos: function todoReducer()&#123;&#125;,</span><br><span class="line">// &#125;</span><br><span class="line">export default function combineReducers(reducers) &#123;</span><br><span class="line">  // 获取参数reducers中的key</span><br><span class="line">  const reducerKeys = Object.keys(reducers)</span><br><span class="line">  // 将reducers重新赋值给finalReducers</span><br><span class="line">  // 这一步主要用于排除reducers中非函数的子reducer</span><br><span class="line">  const finalReducers = &#123;&#125;</span><br><span class="line">  for (let i = 0; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    const key = reducerKeys[i]</span><br><span class="line">    // 保证每个子reducer都是一个函数</span><br><span class="line">    if (typeof reducers[key] === &#x27;function&#x27;) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 重新获取reducers中的key</span><br><span class="line">  const finalReducerKeys = Object.keys(finalReducers)</span><br><span class="line"></span><br><span class="line">  //返回一个函数，参数为当前全局大的state，action</span><br><span class="line">  return function combination(state = &#123;&#125;, action) &#123;</span><br><span class="line">    // 是否已改变</span><br><span class="line">    let hasChanged = false</span><br><span class="line">    // action之后的state</span><br><span class="line">    const nextState = &#123;&#125;</span><br><span class="line">    // 遍历reducer，依次对reducer进行操作</span><br><span class="line">    for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      const key = finalReducerKeys[i]</span><br><span class="line">      const reducer = finalReducers[key]</span><br><span class="line">      // 获取这个子reducer对应的state</span><br><span class="line">      const previousStateForKey = state[key]</span><br><span class="line">      // 调用这个子reducer对state中的数据进行修改</span><br><span class="line">      const nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">      // 将修改后的state赋值给大的state</span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      // 判断state是否改变，只要有一个子state改动过，即判定整个大的state已修改</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    return hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bindActionCreators函数"><a href="#bindActionCreators函数" class="headerlink" title="bindActionCreators函数"></a>bindActionCreators函数</h3><p>bindActionCreator(dealAction,diapatch)函数返回的是一个对象，调用这个对象中（对应相应action）的属性，就会自动创建aciton并dispatch<br>主要作用：将一个或多个action和dispatch组合起来，每一个action中不在具体的调用dispatch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 假如有这样的action</span><br><span class="line">export function addTodo(text) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function removeTodo(id) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    type: &#x27;REMOVE_TODO&#x27;,</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出结果</span><br><span class="line">&#123;</span><br><span class="line">   addTodo : text =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      type: &#x27;ADD_TODO&#x27;,</span><br><span class="line">      text</span><br><span class="line">    &#125;,</span><br><span class="line">   removeTodo : id =&gt; &#123;</span><br><span class="line">      type: &#x27;REMOVE_TODO&#x27;,</span><br><span class="line">      id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//经过bindActionCreators之后</span><br><span class="line">&#123;</span><br><span class="line">   addTodo : text =&gt; dispatch(addTodo(&#x27;text&#x27;));</span><br><span class="line">   removeTodo : id =&gt; dispatch(removeTodo(&#x27;id&#x27;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 对单个actionCreator执行</span><br><span class="line">// 这个函数的主要作用就是返回一个函数，当我们调用返回的这个函数的时候，就会自动的dispatch对应的action</span><br><span class="line">function bindActionCreator(actionCreator, dispatch) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 翻转执行dispatch(actionCreator)</span><br><span class="line">    return dispatch(actionCreator.apply(this, arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 支持传入数组，并对数组中的每一项执行bindActionCreator</span><br><span class="line">export default function bindActionCreators(actionCreators, dispatch) &#123;</span><br><span class="line">  if (typeof actionCreators === &#x27;function&#x27;) &#123;</span><br><span class="line">    return bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const keys = Object.keys(actionCreators)</span><br><span class="line">  const boundActionCreators = &#123;&#125;</span><br><span class="line">  for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    const key = keys[i]</span><br><span class="line">    const actionCreator = actionCreators[key]</span><br><span class="line">    if (typeof actionCreator === &#x27;function&#x27;) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>compose接收一个函数数组，返回一个复合函数<br>解释：<br>例如：compose(f4,f3,f2,f1)(c,d,e)</p>
<ul>
<li>reduce回调函数第一次执行时，返回值为 函数 (…args) =&gt; f4(f3(…args))，作为下一次执行的参数a</li>
<li>回调函数第二次执行时，f2作为参数b，返回值为 函数(…args) =&gt; f4(f3(f2(…args))),作为下一次执行的参数a</li>
<li>回调函数第三次执行时，f1作为参数b，返回值为 函数(…args) =&gt; f4(f3(f2(f1(…args))))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default function compose(...funcs) &#123;</span><br><span class="line">  //没有传入函数参数，就返回一个默认函数（直接返回参数）</span><br><span class="line">  if (funcs.length === 0) &#123;</span><br><span class="line">    return (arg) =&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 单元素数组时调用reduce，会直接返回该元素，不会执行callback;所以这里手动执行</span><br><span class="line">  if (funcs.length === 1) &#123;</span><br><span class="line">    return funcs[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 依次拼凑执行函数</span><br><span class="line">  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>将原来的dispatch函数替换为会遍历执行所有middleware的新的dispatch函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// 依次传入中间件</span><br><span class="line">// applyMiddleware(middlewares1, middlewares2, middlewares3)</span><br><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">  // 返回一个函数，接收原来的createStore，随即有返回一个函数接收reducer和preloadedState</span><br><span class="line">  // enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</span><br><span class="line">    // 调用createStore创建store</span><br><span class="line">    const store = createStore(reducer, preloadedState, enhancer)</span><br><span class="line">    // 保留原来的dispatch函数</span><br><span class="line">    let dispatch = store.dispatch</span><br><span class="line">    // 中间件执行链</span><br><span class="line">    let chain = []</span><br><span class="line"></span><br><span class="line">    // 中间件所需的参数</span><br><span class="line">    const middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;</span><br><span class="line">    // 将middlewareAPI传入每一个中间件并执行返回，</span><br><span class="line">    // 中间形式：</span><br><span class="line">    /**</span><br><span class="line">     *  (&#123; dispatch, getState &#125;) =&gt; next =&gt; (action) =&gt; &#123;</span><br><span class="line">          if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">            return action(dispatch, getState, extraArgument);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return next(action);</span><br><span class="line">        &#125;;</span><br><span class="line">     */</span><br><span class="line">    // 执行之后返回的形式如 middleware：</span><br><span class="line">    /** next =&gt; (action) =&gt; &#123;</span><br><span class="line">      if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">        return action(dispatch, getState, extraArgument);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return next(action);</span><br><span class="line">    &#125;;</span><br><span class="line">  */</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</span><br><span class="line">    // 调用compose函数，将中间件构造成一个执行链，并赋值为新的dispatch函数</span><br><span class="line">    // chain = [middleware1,middleware2,middleware3]</span><br><span class="line">    // dispatch = middlewares1(middlewares2(middlewares3(store.dispatch)))</span><br><span class="line">    // dispatch(action) = middlewares1(middlewares2(middlewares3(store.dispatch)))(action)</span><br><span class="line">    // 对于每一个chain中的next即为执行链中的中间件</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    // 新的createStore的返回值，其实唯一变化的就是dispatch字段。</span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h2><p><code>applyMiddleware(mid1, mid2, mid3, mid4)</code> 最终调用mid1(mid2(mid3(mid4(dispatch))))(action)<br>mid1中的next为mid2，mid2中的next为mid3，以此类推</p>
<ul>
<li>中间件会返回一个复合函数</li>
<li>返回的这个函数接收老的dispatch函数作为参数(也就是代码中的next)，会返回一个新的函数,在redux的applyMiddleware代码中将老的dispatch传入<code>dispatch = compose(...chain)(store.dispatch)</code></li>
<li>新函数就是新的dispatch函数，这个函数里面可以拿到外面两层传进来的getState和老dispatch函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createThunkMiddleware(extraArgument) &#123;</span><br><span class="line">  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; (action) =&gt; &#123;</span><br><span class="line">    if (typeof action === &#x27;function&#x27;) &#123;</span><br><span class="line">      return action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line">export default thunk;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-22/%E6%89%8B%E5%86%99%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-22/%E6%89%8B%E5%86%99%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">手写模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 16:15:35" itemprop="dateCreated datePublished" datetime="2022-02-22T16:15:35+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-28 14:34:33" itemprop="dateModified" datetime="2022-02-28T14:34:33+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="手写模块"><a href="#手写模块" class="headerlink" title="手写模块"></a>手写模块</h1><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>柯里化就是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function sum(a, b, c) &#123;</span><br><span class="line">    console.log(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toCurry(func, ...args) &#123;</span><br><span class="line">  // ↑需要柯里化的函数作为参数</span><br><span class="line">  // ↑也可以有初始参数传入</span><br><span class="line">  // ↑缓存在args中</span><br><span class="line">  return function () &#123;</span><br><span class="line">    // 合并上一次缓存的参数和本次传入的参数</span><br><span class="line">    args = [...args, ...arguments];</span><br><span class="line">    // 判断参数数量是否足够</span><br><span class="line">    if (args.length &lt; func.length) &#123;</span><br><span class="line">      // 如果不够，继续递归</span><br><span class="line">      // 注意，这里每一次递归都会形成新的闭包</span><br><span class="line">      // 保证柯里化函数每一步调用都是独立的，互不影响</span><br><span class="line">      return toCurry(func, ...args);</span><br><span class="line">    &#125; else</span><br><span class="line">      // 如果参数满足数量，执行函数并返回结果</span><br><span class="line">      return func.apply(null, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = toCurry(sum)</span><br><span class="line">f(1)(2)(3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function toCurry() &#123;</span><br><span class="line">  var args = Array.prototype.slice.call(arguments);</span><br><span class="line">  var fn = function () &#123;</span><br><span class="line">    var newArgs = args.concat(Array.prototype.slice.call(arguments));</span><br><span class="line">    return toCurry.apply(this, newArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  fn.toString = function () &#123;</span><br><span class="line">    return args.reduce(function (a, b) &#123;</span><br><span class="line">      return a * b;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  return fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1)(2)(3).toString()</span><br></pre></td></tr></table></figure>
<p>反柯里化：<br>遍历参数，然后调用柯里化函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function uncurrying(fn) &#123;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    var ret = fn; //柯里化函数</span><br><span class="line">    for (let i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">      ret = ret(args[i]); // 反复调用currying版本的函数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret; // 返回结果</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写clone"><a href="#手写clone" class="headerlink" title="手写clone"></a>手写clone</h2><p>JSON.parse(JSON.stringify)的弊端：</p>
<ul>
<li>取不到值为 undefined或者函数 的 key</li>
<li>key为Symbol() 的属性会丢失</li>
<li>对象的原型会丢失，无法获取原型上的属性</li>
<li>NaN 和 无穷大，无穷小转变为 null</li>
<li>循环引用会报错<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function clone(target, map = new WeakMap()) &#123;</span><br><span class="line">  if (typeof target === &#x27;object&#x27;) &#123;</span><br><span class="line">    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    if (map.get(target)) &#123;</span><br><span class="line">      return map.get(target);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line">    for (const key in target) &#123;</span><br><span class="line">      cloneTarget[key] = clone(target[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="手写flat，数组扁平化"><a href="#手写flat，数组扁平化" class="headerlink" title="手写flat，数组扁平化"></a>手写flat，数组扁平化</h2><p>forEach(), filter(), reduce(), every() 和 some() 都会跳过空位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 全部展开</span><br><span class="line">function myFlat(arr, num = 1) &#123;</span><br><span class="line">  var result = [];</span><br><span class="line">  arr.forEach(item =&gt; &#123;</span><br><span class="line">    // 如果元素还是数组，则递归展开</span><br><span class="line">    if (Array.isArray(item) &amp;&amp; num &gt; 0) &#123;</span><br><span class="line">      result = result.concat(arguments.callee(item, num - 1))</span><br><span class="line">      // 或者使用扩展运算符</span><br><span class="line">      // arrResult.push(...arguments.callee(item));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用reduce</span><br><span class="line">function myFlat(arr) &#123;</span><br><span class="line">  return arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    return pre.concat(Array.isArray(cur) ? myFlat(cur) : cur);</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 传入层级函数</span><br><span class="line">function myFlat(arr, num = 1) &#123;</span><br><span class="line">  return num &gt; 0 ? arr.reduce((pre, cur) =&gt; &#123;</span><br><span class="line">    return pre.concat(Array.isArray(cur) ? myFlat(cur, num - 1) : cur);</span><br><span class="line">  &#125;, []) : [].concat(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用栈的方式</span><br><span class="line">function myFlat(arr, num = 1) &#123;</span><br><span class="line">  // 先将原数组入栈</span><br><span class="line">  const stack = [].concat(arr)</span><br><span class="line">  const result = []</span><br><span class="line">  while (stack.length !== 0) &#123;</span><br><span class="line">    // 获取栈顶元素</span><br><span class="line">    const item = stack.pop();</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">      // 如果栈顶的元素还是数组，则将数组再次入栈</span><br><span class="line">      stack.push(...item)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 每一次将元素都放在结果数组的最前面</span><br><span class="line">      result.unshift(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写reduce"><a href="#手写reduce" class="headerlink" title="手写reduce"></a>手写reduce</h2><p>语法：<br>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</p>
<ul>
<li>callback：执行数组中每个值 (如果没有提供 initialValue则第一个值除外)的函数<ul>
<li>accumulator 累计器，是上一次调用回调时返回的累积值，或initialValue</li>
<li>currentValue： 当前值</li>
<li>index: 当前索引</li>
<li>array: 源数组</li>
</ul>
</li>
<li>initialValue：初始值，默认为数组的第一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//简单版</span><br><span class="line">function myReduce(arr, func, initValue) &#123;</span><br><span class="line">  // 处理回调类型异常 必须是函数</span><br><span class="line">  if (Object.prototype.toString.call(func) != &quot;[object Function]&quot;) &#123;</span><br><span class="line">    throw new TypeError(func + &quot; is not a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 空数组不操作</span><br><span class="line">  if (arr.length &lt;= 0) &#123;</span><br><span class="line">    return arr</span><br><span class="line">  &#125;</span><br><span class="line">  var num = initValue === undefined ? arr[0] : 0;</span><br><span class="line">  var startIndex = initValue === undefined ? 0 : 1;</span><br><span class="line"></span><br><span class="line">  for (var i = startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num = func(num, arr[i], i, arr);</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//挂载在原型上</span><br><span class="line">Array.prototype.myReduce = function (func, initialValue) &#123;</span><br><span class="line">  // 处理回调类型异常 必须是函数</span><br><span class="line">  if (Object.prototype.toString.call(func) != &quot;[object Function]&quot;) &#123;</span><br><span class="line">    throw new TypeError(func + &quot; is not a function&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 空数组不操作</span><br><span class="line">  if (this.length &lt;= 0) &#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var num = initialValue || this[0];</span><br><span class="line">  var startIndex = initialValue ? 0 : 1;</span><br><span class="line"></span><br><span class="line">  for (var i = startIndex; i &lt; this.length; i++) &#123;</span><br><span class="line">    num = func(num, this[i], i, this);</span><br><span class="line">  &#125;</span><br><span class="line">  return num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>触发事件后n秒后才执行函数，如果在n秒内触发了事件，则会重新计算函数执行时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function debounce(func, wait, immediate) &#123;</span><br><span class="line"></span><br><span class="line">    var timeout, result;</span><br><span class="line"></span><br><span class="line">    var debounced = function () &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line"></span><br><span class="line">        if (timeout) clearTimeout(timeout);</span><br><span class="line">        if (immediate) &#123;</span><br><span class="line">            // 如果已经执行过，不再执行</span><br><span class="line">            var callNow = !timeout;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            if (callNow) result = func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            timeout = setTimeout(function()&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    debounced.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>连续触发事件但在n秒内只执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    if (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var later = function() &#123;</span><br><span class="line">        previous = options.leading === false ? 0 : new Date().getTime();</span><br><span class="line">        timeout = null;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        if (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled = function() &#123;</span><br><span class="line">        var now = new Date().getTime();</span><br><span class="line">        if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">        var remaining = wait - (now - previous);</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            if (!timeout) context = args = null;</span><br><span class="line">        &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    throttled.cancel = function() &#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = 0;</span><br><span class="line">        timeout = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手写-call-apply-bind-new"><a href="#手写-call-apply-bind-new" class="headerlink" title="手写 call/apply/bind/new"></a>手写 call/apply/bind/new</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;ljt&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line"></span><br><span class="line">  sayHello: function (prefix = &#x27;&#x27;) &#123;</span><br><span class="line">    console.log(prefix + &#x27;--&gt;&#x27; + this.name + &quot;:&quot; + this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;cdw&#x27;,</span><br><span class="line">    age: 29,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHello(&#x27;hz&#x27;)</span><br><span class="line">// hz--&gt;ljt:30</span><br><span class="line"></span><br><span class="line">person.sayHello.call(obj,&#x27;hn&#x27;)</span><br><span class="line">// hn--&gt;cdw:20</span><br></pre></td></tr></table></figure>

<p>手写call：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myCall = function (context) &#123;</span><br><span class="line">  const obj = (typeof context === &quot;object&quot;) ? context : window</span><br><span class="line">  // 防止覆盖掉原有属性</span><br><span class="line">  const key = Symbol()</span><br><span class="line"></span><br><span class="line">  // 这里的this为需要执行的方法</span><br><span class="line">  obj[key] = this;</span><br><span class="line"></span><br><span class="line">  // 获取剩余参数</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line"></span><br><span class="line">  // 方法执行</span><br><span class="line">  const result = obj[key](args)</span><br><span class="line"></span><br><span class="line">  //删除对象中的方法</span><br><span class="line">  delete obj[key]</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply函数和call函数类似，只是apply的参数是通过数组来传递</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;ljt&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line"></span><br><span class="line">  sayHello: function (prefix = &#x27;&#x27;) &#123;</span><br><span class="line">    console.log(prefix + &#x27;--&gt;&#x27; + this.name + &quot;:&quot; + this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;cdw&#x27;,</span><br><span class="line">    age: 29,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHello(&#x27;hz&#x27;)</span><br><span class="line">// hz--&gt;ljt:30</span><br><span class="line"></span><br><span class="line">person.sayHello.apply(obj,[&#x27;hn&#x27;])</span><br><span class="line">// hn--&gt;cdw:20</span><br></pre></td></tr></table></figure>

<p>apply实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myApply = function (context) &#123;</span><br><span class="line">  const obj = (typeof context === &quot;object&quot;) ? context : window</span><br><span class="line">  // 防止覆盖掉原有属性</span><br><span class="line">  const key = Symbol()</span><br><span class="line"></span><br><span class="line">  // 这里的this为需要执行的方法</span><br><span class="line">  obj[key] = this;</span><br><span class="line"></span><br><span class="line">  // 获取剩余参数</span><br><span class="line">  const args = [...arguments].slice(1)</span><br><span class="line">  // 方法执行</span><br><span class="line">  // 注意这里和call不相同，需要把参数展开</span><br><span class="line">  const result = obj[key](...args)</span><br><span class="line"></span><br><span class="line">  //删除对象中的方法</span><br><span class="line">  delete obj[key]</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &#x27;ljt&#x27;,</span><br><span class="line">  age: 30,</span><br><span class="line"></span><br><span class="line">  sayHello: function (prefix = &#x27;&#x27;) &#123;</span><br><span class="line">    console.log(prefix + &#x27;--&gt;&#x27; + this.name + &quot;:&quot; + this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name:&#x27;cdw&#x27;,</span><br><span class="line">    age: 29,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.sayHello(&#x27;hz&#x27;)</span><br><span class="line">// hz--&gt;ljt:30</span><br><span class="line"></span><br><span class="line">const fn = person.sayHello.bind(obj)</span><br><span class="line">fn(&#x27;hn&#x27;)</span><br><span class="line">// hn--&gt;cdw:20</span><br></pre></td></tr></table></figure>

<p>bind实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&#x27;mac this&#x27;, this);</span><br><span class="line">  self = this;</span><br><span class="line"></span><br><span class="line">  // 获取该方法剩余参数</span><br><span class="line">  const args = [...arguments].slice(1);</span><br><span class="line"></span><br><span class="line">  // 设置返回的一个新方法</span><br><span class="line">  const result = function () &#123;</span><br><span class="line"></span><br><span class="line">    // 获取返回方法体的参数</span><br><span class="line">    const resultArgs = [...arguments];</span><br><span class="line">    // 如果是通过 new 调用的，绑定 this 为实例对象</span><br><span class="line">    if (this instanceof result) &#123;</span><br><span class="line">      self.apply(this, args.concat(resultArg));</span><br><span class="line">    &#125; else &#123; // 否则普通函数形式绑定 context</span><br><span class="line">      self.apply(context, args.concat(resultArg));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 绑定原型链</span><br><span class="line"></span><br><span class="line">  // 如果这样写 result.prototype = this.prototype</span><br><span class="line">  // 重写了默认的 prototype 对象，因此其 constructor 属性也指向了完全不同 的新对象(Object 构造函数)，不再指向原来的构造函数</span><br><span class="line">  // 原型式继承</span><br><span class="line">  function object(o) &#123;</span><br><span class="line">      function F() &#123;&#125;</span><br><span class="line">      F.prototype = o;</span><br><span class="line">      return new F();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result.prototype = Object.create(this.prototype);</span><br><span class="line"></span><br><span class="line">  // 返回结果</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new的主要操作：</p>
<ul>
<li>1、创建一个新的对象</li>
<li>2、将想的对象的__proto__执行构造函数的prototype对象</li>
<li>3、构造函数的this被赋值为这个新对象</li>
<li>4、执行构造函数的内部代码，为这个新对象增加属性</li>
<li>5、如果构造函数返回非空对象，则返回这个非空对象，否则返回新创建的对象<br>方式一：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function _new(obj, ...rest) &#123;</span><br><span class="line">  // 基于obj的原型创建一个新的对象</span><br><span class="line">  const newObj = Object.create(obj.prototype);</span><br><span class="line"></span><br><span class="line">  // 添加属性到新创建的newObj上, 并获取obj函数执行的结果.</span><br><span class="line">  const result = obj.apply(newObj, rest);</span><br><span class="line"></span><br><span class="line">  // 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象</span><br><span class="line">  return typeof result === &#x27;object&#x27; ? result : newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>方式二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function _new() &#123;</span><br><span class="line">  const obj = new Object();</span><br><span class="line">  // arguments第一个值是构造函数</span><br><span class="line">  constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">  obj.__proto__ = constructor.prototype;</span><br><span class="line">  constructor.apply(obj, arguments);</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-17/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-17/JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">JS的类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-17 16:28:48 / 修改时间：16:29:07" itemprop="dateCreated datePublished" datetime="2022-02-17T16:28:48+08:00">2022-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JS的类型转换"><a href="#JS的类型转换" class="headerlink" title="JS的类型转换"></a>JS的类型转换</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul>
<li>当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型</li>
<li>当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型</li>
<li>当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接<h3 id="减、乘、除"><a href="#减、乘、除" class="headerlink" title="减、乘、除"></a>减、乘、除</h3>我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - true // 0， 首先把 true 转换为数字 1， 然后执行 1 - 1</span><br><span class="line">1 - null // 1,  首先把 null 转换为数字 0， 然后执行 1 - 0</span><br><span class="line">1 * undefined //  NaN, undefined 转换为数字是 NaN</span><br><span class="line">2 * [&#x27;5&#x27;] //  10， [&#x27;5&#x27;]首先会变成 &#x27;5&#x27;, 然后再变成数字 5</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用-比较中的5条规则"><a href="#使用-比较中的5条规则" class="headerlink" title="使用 == 比较中的5条规则"></a>使用 == 比较中的5条规则</h3><ul>
<li><p>规则 1：NaN和其他任何类型比较永远返回false（包括和他自己</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN == NaN // false</span><br></pre></td></tr></table></figure></li>
<li><p>规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true == 1  // true</span><br><span class="line">true == &#x27;2&#x27;  // false, 先把 true 变成 1，而不是把 &#x27;2&#x27; 变成 true</span><br><span class="line">true == [&#x27;1&#x27;]  // true, 先把 true 变成 1， [&#x27;1&#x27;]拆箱成 &#x27;1&#x27;, 再参考规则3</span><br><span class="line">true == [&#x27;2&#x27;]  // false, 同上</span><br><span class="line">undefined == false // false ，首先 false 变成 0，然后参考规则4</span><br><span class="line">null == false // false，同上</span><br></pre></td></tr></table></figure></li>
<li><p>规则 3：String和Number比较，先将String转换为Number类型</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123 == &#x27;123&#x27; // true, &#x27;123&#x27; 会先变成 123</span><br><span class="line">&#x27;&#x27; == 0 // true, &#x27;&#x27; 会首先变成 0</span><br></pre></td></tr></table></figure></li>
<li><p>规则 4：null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">null == undefined // true</span><br><span class="line">null == &#x27;&#x27; // false</span><br><span class="line">null == 0 // false</span><br><span class="line">null == false // false</span><br><span class="line">undefined == &#x27;&#x27; // false</span><br><span class="line">undefined == 0 // false</span><br><span class="line">undefined == false // false</span><br></pre></td></tr></table></figure></li>
<li><p>规则 5： 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型。</p>
<ul>
<li>ToPrimitive规则，是引用类型向原始类型转变的规则，它遵循先valueOf后toString的模式期望得到一个原始类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;[object Object]&#x27; == &#123;&#125;</span><br><span class="line">// true, 对象和字符串比较，对象通过 toString 得到一个基本类型值</span><br><span class="line">&#x27;1,2,3&#x27; == [1, 2, 3]</span><br><span class="line">// true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-17/React%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-17/React%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">React知识点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-17 10:39:57 / 修改时间：11:22:05" itemprop="dateCreated datePublished" datetime="2022-02-17T10:39:57+08:00">2022-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-10/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-10/webpack%E7%83%AD%E6%9B%B4%E6%96%B0/" class="post-title-link" itemprop="url">webpack热更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-10 09:43:53" itemprop="dateCreated datePublished" datetime="2022-02-10T09:43:53+08:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-17 09:44:36" itemprop="dateModified" datetime="2022-02-17T09:44:36+08:00">2022-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="webpack热更新-HMR"><a href="#webpack热更新-HMR" class="headerlink" title="webpack热更新 HMR"></a>webpack热更新 HMR</h1><p>Webpack热更新（ Hot Module Replacement，简称 HMR），可以使开发者无需完全刷新整个页面的同时，更新所有类型的模块，是 Webpack 提供的最有用的功能之一。<br>HMR作为一个webpack内置的功能，可以通过HotModuleReplacementPlugin或–hot开启</p>
<h2 id="webpack热更新的原理"><a href="#webpack热更新的原理" class="headerlink" title="webpack热更新的原理"></a>webpack热更新的原理</h2><p>介绍webpack-dev-server:<br>webpack-dev-server 主要包含了三个部分：</p>
<ul>
<li>1.webpack: 负责编译代码</li>
<li>2.webpack-dev-middleware: 主要负责构建内存文件系统，把webpack的 OutputFileSystem 替换成 InMemoryFileSystem。同时作为Express的中间件拦截请求，从内存文件系统中把结果拿出来。</li>
<li>3.express：负责搭建请求路由服务</li>
</ul>
<p>详细过程</p>
<ul>
<li>1.启动dev-server，webpack开始构建、注册webpack编译完成事件回调，启动本地HTTP静态资源服务，Client和Server之间建立一个 websocket 长连接</li>
<li>2.webpack-dev-middleware中间件将文件系统设置为内存文件系统，并监听文件的变化</li>
<li>3.修改文件，Server端watch监听文件发送变动，webpack开始编译，直到编译完成会触发”Done”事件；</li>
<li>4.Server通过socket 发送消息告知 Client；</li>
<li>5.Client根据Server的消息（hash值和state状态），向webpack发送webpackHotUpdate事件</li>
<li>6、webpack会监听webpackHotUpdate事件调用调用module.hot.check方法进行热更新。</li>
<li>7、通过ajax请求获取 Server 的manifest描述文件，获取服务器这一次编译相对于上一次编译改变了哪些module和chunk</li>
<li>8.通过JSONP请求获取到最新的模块代码</li>
<li>9.Client获取到新的JS模块后，进行模块热更新；</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/hot-module-replacement">官方文档</a><br><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/118">介绍下 webpack 热更新原理</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020310371">彻底搞懂并实现webpack热更新原理</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904008432222215">轻松理解webpack热更新原理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-09/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-09/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/" class="post-title-link" itemprop="url">发布一个npm包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-09 16:16:35" itemprop="dateCreated datePublished" datetime="2022-02-09T16:16:35+08:00">2022-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-16 17:48:09" itemprop="dateModified" datetime="2022-02-16T17:48:09+08:00">2022-02-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NPM库制作"><a href="#NPM库制作" class="headerlink" title="NPM库制作"></a>NPM库制作</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1、注册账号 <a target="_blank" rel="noopener" href="https://www.npmjs.com/">https://www.npmjs.com/</a><br>2、本机Node环境<br>3、实现功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">制作一个lib包，实现输入一个名字，然后将名字全部小写，并输出：hello! ljt 2022-02-15 12:24:37</span><br><span class="line">比如输入cdw或者cdW hello! cdw 2022-02-15 12:24:37</span><br></pre></td></tr></table></figure>

<h2 id="简单的NPM包"><a href="#简单的NPM包" class="headerlink" title="简单的NPM包"></a>简单的NPM包</h2><p>第一步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;ljt-lib&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test包&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;test&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;ljt&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次输入相关的信息，形成package.json文件</p>
<p>第二步：<br>先导入所需的外部库，这里我们使用lodash和moment</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash</span><br><span class="line">npm install moment</span><br></pre></td></tr></table></figure>
<p>执行以上两步后，会安转lodash和moment两个外部库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;ljt-lib&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test包&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;test&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;ljt&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  // 安装的第三方库</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;lodash&quot;: &quot;^4.17.21&quot;,</span><br><span class="line">    &quot;moment&quot;: &quot;^2.29.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：<br>编写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; toLower &#125; = require(&quot;lodash&quot;)</span><br><span class="line">const moment = require(&#x27;moment&#x27;)</span><br><span class="line">function sayHello(name = &#x27;ljt&#x27;) &#123;</span><br><span class="line">  return &#x27;hello!&#x27; + &#x27; &#x27; + toLower(name) + &#x27; &#x27; + moment().format(&quot;YYYY-MM-DD HH:mm:ss&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  sayHello</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第四步：<br>将编写好的包发布至npm仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm login // 登录</span><br><span class="line">npm publish //发布</span><br><span class="line">npm unpublish ljt-lib --force //删除包</span><br></pre></td></tr></table></figure>

<p>第五步：<br>在项目中引用刚刚发布的包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install ljt-lib</span><br><span class="line"></span><br><span class="line">const &#123; sayHello &#125; = require(ljt-lib)</span><br><span class="line">const hello = sayHello(&#x27;CDW)</span><br><span class="line">console.log(hello)</span><br></pre></td></tr></table></figure>

<p>第六步：<br>如果需要更新包，则需要修改package.json中的version字段，然后重新发布</p>
<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><h3 id="package-json中dependencies和devDependencies的区别"><a href="#package-json中dependencies和devDependencies的区别" class="headerlink" title="package.json中dependencies和devDependencies的区别"></a>package.json中<code>dependencies</code>和<code>devDependencies</code>的区别</h3><p>dependencies：生产环境所需要依赖，例如：Vue，React 等，如果缺少依赖项目就运行错误<br>devDependencies:字面意思就是开发依赖，开发时候才会用到的工具包，例如：webpack，eslint等，等项目上线后不需依赖相关代码运行的工具</p>
<p>单单从概念上理解会比较难，我们从两方面来理解：</p>
<ul>
<li><p>第一、在项目中<br>我们在开发项目中，我们一般使用<code>npm install &lt;package&gt;</code>或<code>npm install &lt;package&gt; --save-dev</code>来分别安装dependencies和devDependencies，这个时候会把包都安装在node_modules文件夹下，同时会生成一个<code>package-lock.json</code>文件。如果第三个使用这个项目的源码，执行<code>npm install</code>，则会安装所有的依赖。打包的时候不管你的依赖是在<code>dependencies</code>中，还是<code>devDependencies</code>中都会打包进去。以webpack为例，从入口文件开始构建依赖树，如果你的代码中引用了某个依赖就会被打包进进去。<br>这个时候安转在哪里其实没有什么区别，可以看作成一个规范和约束</p>
</li>
<li><p>第二、NPM库中<br>如果在制作NPM库中，这两个字段的差异就比较大了，当别人使用制作好的NPM包时<code>npm install &lt;package&gt;</code>，只会安装<code>dependencies</code>中的依赖，而不会去下载<code>devDependencies</code>中的依赖。如果将开发相关的依赖放到了<code>dependencies</code>依赖中，比如把<code>jest</code>放入到<code>dependencies</code>依赖，那么就会下载<code>jest</code>到别人的项目中，无形中增加了项目的体积。</p>
</li>
</ul>
<p>除了<code>dependencies</code>和<code>devDependencies</code>这两个依赖相关的字段还有其他几个字段</p>
<ul>
<li>peerDependencies 同等依赖，或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本.</li>
<li>optionalDependencies 可选依赖，如果有一些依赖包即使安装失败，项目仍然能够运行或者希望npm继续运行，就可以使用optionalDependencies</li>
<li>bundledDependencies 作者希望以压缩包（tar.gz）的方式发布项目，即没有 publish 到 npm register 上的包 这个字段不常用</li>
</ul>
<h2 id="增加webpack打包机制"><a href="#增加webpack打包机制" class="headerlink" title="增加webpack打包机制"></a>增加webpack打包机制</h2><p>第一步制作的NPM包有几个局限，使用了commonjs规范、无法使用ES6语法、无法减小包的体积等。如果使用webpack打包，则可以解决上述问题。</p>
<ul>
<li><p>先修改一下原先项目的目录<br><img src="https://forexmastertest.oss-cn-beijing.aliyuncs.com/MY_BLOG/55.png" alt="avatar"><br>lib文件夹下放打包好的文件</p>
</li>
<li><p>使用es6语法编写代码</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// module.js</span><br><span class="line">const sayHello = (name) =&gt; &#123;</span><br><span class="line">  return &#x27;hello!&#x27; + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; sayHello &#125;</span><br><span class="line"></span><br><span class="line">// index.js</span><br><span class="line">import &#123; sayHello &#125; from &#x27;./module&#x27;</span><br><span class="line">export &#123;</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改package.json文件,具体修改看注释</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;ljt-lib&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.16&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test包&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;lib/main.js&quot;, //指定包的入口，即第三方安装后由这里加载</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;, // 增加webpack打包命令</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;test&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;lib/*.js&quot; // 指定那些文件会被上传至NPM库中</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;ljt&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^5.69.0&quot;, // webpack相关依赖</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^4.9.2&quot; // webpack相关依赖</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>增加webpack.config.js配置文件,这个配置文件需要特别关注<code>libraryTarget: &#39;umd&#39;,</code>，这里表示要将这个lib包以什么规范来打包，也就是第三方能够已何种方式来使用（script标签/umd、npm安装包/commonjs）</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;none&#x27;,</span><br><span class="line">  entry: &#x27;./index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#x27;lib&#x27;),</span><br><span class="line">    filename: &quot;[name].js&quot;,</span><br><span class="line">    libraryTarget: &#x27;umd&#x27;,</span><br><span class="line">    clean: true</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>npm run build</code>编译无误后，按照第一部分的步骤发布即可</p>
<h2 id="移除外部模块"><a href="#移除外部模块" class="headerlink" title="移除外部模块"></a>移除外部模块</h2><p>这个怎么理解呢，就是如果你在自己的包中使用了另一个第三方包，比如<code>lodash</code>,假如不做处理，你的build后的包的体积会很大，因为引入了<code>lodash</code>，这时我们可以将<code>lodash</code>排除在webpack打包之外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#x27;./index.js&#x27;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#x27;lib&#x27;),</span><br><span class="line">    filename: &quot;[name].js&quot;,</span><br><span class="line">    libraryTarget: &#x27;umd&#x27;,</span><br><span class="line">    clean: true</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: &#123;</span><br><span class="line">    lodash: &#x27;lodash&#x27;,</span><br><span class="line">    // lodash: &#123;</span><br><span class="line">    //   commonjs: &#x27;lodash&#x27;,</span><br><span class="line">    //   commonjs2: &#x27;lodash&#x27;,</span><br><span class="line">    //   amd: &#x27;lodash&#x27;,</span><br><span class="line">    //   root: &#x27;_&#x27;,</span><br><span class="line">    // &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="externals和libraryTarget"><a href="#externals和libraryTarget" class="headerlink" title="externals和libraryTarget"></a>externals和libraryTarget</h2><p>externals指定那些外部模块需要从打包后的bundle中移除，并且还指定了引入外部模块所加载的模式<br>libraryTarget指定以那种规范打包，同时也决定了以哪种模式去加载所引入的外部模块。也就是说，externals应该和libraryTarget保持一致。如果library运行在浏览器中的，你设置externals的模式为commonjs，那其实是运行不了的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022-02-09/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022-02-09/%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/" class="post-title-link" itemprop="url">垂直水平居中</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-09 13:16:09 / 修改时间：13:16:33" itemprop="dateCreated datePublished" datetime="2022-02-09T13:16:09+08:00">2022-02-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/css/" itemprop="url" rel="index"><span itemprop="name">css</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="垂直，水平居中"><a href="#垂直，水平居中" class="headerlink" title="垂直，水平居中"></a>垂直，水平居中</h1><h2 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;hello world&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="display-flex"><a href="#display-flex" class="headerlink" title="display: flex"></a>display: flex</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center; /* 水平居中 */</span><br><span class="line">  align-items: center; /* 垂直居中 */</span><br><span class="line">&#125;</span><br><span class="line">// 或者</span><br><span class="line">.outer &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner &#123;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：不需要固定居中元素的宽高。</p>
<h3 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h3><p>translate 属性是根据元素自身计算来这是偏移量，<br><code>transform: translateX(-50%);</code>，元素会向左偏移自身宽度的一半</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：不需要固定居中元素的宽高。</p>
<h3 id="absolute-负-margin"><a href="#absolute-负-margin" class="headerlink" title="absolute + 负 margin"></a>absolute + 负 margin</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.outer &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px; // 设置元素宽度</span><br><span class="line">  height: 100px; // 设置元素高度</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  margin-left: -50px;</span><br><span class="line">  margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：需要固定居中元素的宽高</p>
<h3 id="absolute-calc"><a href="#absolute-calc" class="headerlink" title="absolute + calc"></a>absolute + calc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px; // 设置元素宽度</span><br><span class="line">  height: 100px; // 设置元素高度</span><br><span class="line">  left: calc(50% - 50px);</span><br><span class="line">  top: calc(50% - 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：需要固定居中元素的宽高</p>
<h3 id="absolute-margin-auto"><a href="#absolute-margin-auto" class="headerlink" title="absolute + margin: auto"></a>absolute + margin: auto</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100px; // 设置元素宽度</span><br><span class="line">  height: 100px; // 设置元素高度</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：需要固定居中元素的宽高，否则其宽高会被设为 100%（副作用）</p>
<h3 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h3><p>修改dom结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>css:<br>原理：<br>writing-mode 不仅可以使文字显示方向改变，还能使所有作用于水平方向上的属性，变成作用于垂直方向。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">  width: 300px;</span><br><span class="line">  height: 300px;</span><br><span class="line">  writing-mode: vertical-lr; // 改变容器内子元素的布局方向</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// inner中设置height：auto实际上会让元素垂直居中，因为父元素设置了writing-mode: vertical-lr</span><br><span class="line">// inner中重新设置 writing-mode: horizontal-tb，将显示方向改变回来</span><br><span class="line">.inner &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: auto;</span><br><span class="line">  writing-mode: horizontal-tb;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体显示内容</span><br><span class="line">.content &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  text-align: left; /* 重置文字位置（如果需要） */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：不需要固定居中元素的宽高。<br>缺点：需要修改 DOM 结构（为了居中元素，需要嵌套两层父元素）。</p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>除了水平垂直居中里面的方法外，还有几种方法可以用来实现水平居中</p>
<h3 id="text-align-inline-block"><a href="#text-align-inline-block" class="headerlink" title="text-align + inline-block"></a>text-align + inline-block</h3><p><code>text-align: center;</code> 会使文本居中，但是对块级元素无效，如果将元素设置为 inline-block，该元素就会被当做文本对待，从而实现元素居中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：不需要固定居中元素的宽。<br>缺点：为了居中元素，使文本也居中了，因此可能需要重置文本位置。</p>
<h3 id="fit-content-margin"><a href="#fit-content-margin" class="headerlink" title="fit-content + margin"></a>fit-content + margin</h3><h4 id="直接应用于元素"><a href="#直接应用于元素" class="headerlink" title="直接应用于元素"></a>直接应用于元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.inner &#123;</span><br><span class="line">  width: fit-content;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：会使元素的宽度改变（同内容宽度）。</p>
<h4 id="应用于元素的父元素上"><a href="#应用于元素的父元素上" class="headerlink" title="应用于元素的父元素上"></a>应用于元素的父元素上</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;</span><br><span class="line">  width: fit-content;</span><br><span class="line">  margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：即使子元素是浮动元素也适用。<br>缺点：兼容性较差，目前只支持Chrome 和 Firefox浏览器</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hexo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hexo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
